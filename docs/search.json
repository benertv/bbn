[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Updates des Projekts E-Valuate - Auf dem Weg zum lernenden Staat",
    "section": "",
    "text": "Updates des Projekts E-Valuate - Auf dem Weg zum lernenden Staat\nAuf den folgenden Seiten findet ihr:\n\nTutorials zu Datenanalysen und Wirkungsorientierung\nCode- und Ergebnisdokumentationen zu den Datenanalysen aus dem E-Valuate-Projekt\nProjektupdates in Form von Blogbeiträgen.\n\nAusführliche Projektinformationen gibt es auf der offiziellen Projektwebsite: E-Valuate - Auf dem Weg zum lernenden Staat\nWir freuen uns über Feedback und Themenvorschläge. Schreibt uns dazu gern eine Mail an vivien.benert@agoradigital.de.\n\n\n\nQuelle: Agora Digitale Transformation"
  },
  {
    "objectID": "index.html#einführung-bayessche-netzwerke-und-directed-acyclic-graphs",
    "href": "index.html#einführung-bayessche-netzwerke-und-directed-acyclic-graphs",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "",
    "text": "Bayes’sche Netzwerke (BN), auch Bayes’sche Netze genannt, sind graphische Modelle der Kausalannahmen zwischen Variablen. Durch das hinterlegen des Modells mit bedingten Wahrscheinlichkeiten für jede Kausalbeziehung lassen sich die kausalen Abhängigkeiten zwischen einzelnen Variablen im Modell besser darstellen als bspw. bei einer multiplen Regression. Zudem kann das Modell auf bestimmte Werte für einzelne Variablen konditioniert werden und die Auswrikung dieser Veränderung auf die anderen Variablen im Modell lassen sich berechnen.\nFür die Berechnung und Darstellung Bayes’scher Netzwerke in R gibt es eine ganze Reihe an Paketen. Im folgenden Arbeiten wir mit den folgenden Paketen:\n\nbnlearn ist ein Paket von Marco Scutari zum Erlernen der grafischen Struktur von Bayes’schen Netzwerken, zum Schätzen ihrer Parameter und zum Durchführen probabilistischer und kausaler Inferenz.\ngRain ist ein Paket für Wahrscheinlichkeitsausbreitung in grafischen Unabhängigkeitsnetzwerken (dazu zählen auch Bayes’sche Netzwerke).\nigraph ist ein Paket für Netzwerkanalysen und Visualisierungen.\n\n\n&gt; # Pakete laden\n&gt; library(bnlearn)\n&gt; library(gRain)\n&gt; library(igraph)\n\nDie Kausalannahmen eines theoretischen Modells werden als Netzwerk dargestellt, in dem die Zufallsvariablen die Knoten darstellen und der angenommene Kausalzusammenhang zwischen mindestens zwei Variablen als ein Pfeil abgebildet wird. Diese Pfeile werden Kanten genannt. Die Pfeilrichtung entspricht dabei der angenommenen Kausalrichtung.\nEs ist auch möglich, dass zwei Knoten in einem Netzwerk durch eine Kante ohne Pfeilspitze verbunden sind. In diesem Fall handelt es sich um ein ungerichtetes Netzwerk, die Richtung der Beziehung zwischen den Knoten ist also nicht klar. Netzwerke, in denen die Richtung der Kanten durch Pfeile angegeben sind, heißen gerichtete Netzwerke. Für Kausalanalysen sind immer gerichtete Netzwerke notwendig, da die angenommenene Richtung des Kausaleinflusses zwischen zwei Variablen klar sein muss.\nHier ein ganz simples Beispiel für ein gerichtetes Netzwerk:\n\n\n\n\n\nAbb. 1: Ein einfacher, gerichteter Graph mit zwei Knoten und einer Kante\n\n\n\n\n\n\nBayes’sches Netzwerk: Ein Bayes’sches Netz ist ein graphical model for representing knowledge about an uncertain domain where each node corresponds to a random variable and each edge represents the conditional probability for the corresponding random variables (Yang, 2019, S. 35). Bayes’sche Netzwerke basieren auf zwei zentralen Konzepten: den DAGs (Directed Acyclic Grpahs) und den bedingten Wahrscheinlichkeitstabellen (Conditional Probability Tables oder CPTs).\nDAGs: Die Abkürzung DAG steht für “Directed Acyclic Graphs”, also gerichtete Netzwerke ohne Zirkelschlüsse. Die Kausalannahmen eines theoretischen Modells werden in Form eines Netzwerkes dargstellt. Um daraus inferenzstatistische Schlüsse ziehen zu können, werden die Variablen, die die Knoten des Netzwerks bilden, mit Variablen und empirischen Daten hinterlegt (vgl. dazu die Abschnitte 2 und 4).\nBedingte Wahrscheinlichkeitstabellen: Bedingte Wahrscheinlichkeitstabellen (Conditional Probability Tables) geben die Wahrscheinlichkeiten der im Modell vorhandenen Variablen an. Bedingte Wahrscheinlichkeiten geben die Wahrscheinlichkeit einer Variable in Abhängigkeit einer anderen Variable an. Wie bedingte Wahrscheinlichkeitstabellen berechnet werden können, schauen wir uns in Kapitel X genauer an.\n\n\n\n\nNetzwerkgraphen sind die grafische Darstellung der Kausalbeziehungen zwischen Variablen. Sie bilden das theoretische Modell der Zusammenhänge zwischen den untersuchten Variablen ab. Sie müssen ein paar Bedingungen erfüllen:\n1) Der Graph muss gerichtet sein, d.h. die Kausalannahmen zwischen den Variablen sind durch die Pfeilrichtungen im Netzwerk dargstellt.\nSo einen Graphen kennen wir bereits:\n\n\n\n\n\nAbb. 2: Ein einfacher, gerichteter Graph\n\n\n\n\n2) Der Netzwerkgraph darf keine Loops enthalten.\n\n\n\n\n\nAbb. 3: Ein Graph mit Selbstreferenz (Loop) des Knotens A\n\n\n\n\nEin Loop ist eine Kante, die von einem Konten auf sich selbst verweist. Im Rahmen von Bayes’schen Netzwerken, in denen die Knoten für Variablen und die Kanten für Kausalbeziehungen zwischen den Variablen stehen, würde ein Loop bedeuten, dass sich eine Variable selbst erklärt. Das widerspricht den grundsätzlichen Annahmen Bayes’scher Netzwerke, auch wenn eine solche Situation theoretisch möglich ist (z. B. wenn man annimmt, dass Menschen mit viel Vermögen mehr Vermögen ansammeln, zum Beispiel durch Kapitalanlagen und Zinseszinseffekte, sodass man stark vereinfacht annehmen könnte, dass das Vermögen sich selbst beeinflusst).\n3) Der Graph muss azyklisch sein.\n\n\n\n\n\nAbb. 4: Ein zyklischer Graph\n\n\n\n\nAchtung: Hier kommt es auf die Richtung der Pfeile an. Bei dieser Variante handelt es sich NICHT um einen zyklischen Graphen:\n\n\n\n\n\nAbb. 5: Ein azyklischer Graph\n\n\n\n\n\n\n\nUm Bayes’sche Netzwerke (BN) besser zu verstehen, müssen wir uns mit ein paar Begrifflichkeiten vertraut machen. Die Kausalbeziehungen im Netzwerk werden durch das Verhältnis der Knoten zueinander dargestellt. Dazu wird in der Netzwerkliteratur der Vergleich mit Verwandschaftsbeziehungen genutzt. Die abhänigen Variablen im Netzwerk werden daher als “children” (Kinder) der unabhängigen Variablen (“parents”, Eltern) bezeichnet.\nIn einem simplen BN mit A –&gt; B wäre A also der Parent und B das Kind (Child).\n\n\n\n\n\nAbb. 6: Eltern- und Kind-Knoten in einem einfachen Graphen\n\n\n\n\nIn einem etwas komplexeren Graphen können Knoten auch mehrere parents (grün) sowie children (grau) haben.\n\n\n\n\n\nAbb. 7: Graph mit mehreren Eltern- und Kind-Knoten\n\n\n\n\n\n\n\nDAGs können immer in drei fundamentale Strukturen zerlegt werden, die die Grundlage für die sogenannte D-Seperation bilden. D-Seperation ist ein zentrales Konzept in Bayes’schen Netzwerken für die Überprüfung der Abhängigkeit oder Unabhängigkeit von zwei Variablen.\n1) Serial: Die serielle Struktur\n\n\n\n\n\nAbb. 8: Serielle Struktur\n\n\n\n\nIn der seriellen Struktur besteht ein Kausalzusammenhang von A zu B und von B zu C. B fungiert also als Mediatorvariable des Einflusses von A auf C. Im Kontext der D-Separation sind A und C somit zunächst - indirekt - abhängig voneinander. Wenn man jedoch auf B konditioniert, blockiert B den Weg von A zu C und diese werden unabhängig voneinander. Mit anderen Worten: Wenn für B ein bestimmter Zustand festgelegt wird, für den der Einfluss auf C berechnet werden soll, wird der Zustand von A irrelevant für die Berechnung der Wahrscheinlichkeit von C.\n2) Divergent: Die divergente Struktur\n\n\n\n\n\nAbb. 9: Divergente Struktur\n\n\n\n\nIn der divergenten Struktur sind A und C Child-Knoten von B. B beeinflusst also sowohl A als auch C. In der D-Seperation sind A und C zunächst abhängig voneinander. Dies ändert sich jedoch, wenn man auf B konditioniert: B blockiert den Pfad von A zu C, wenn wir auf B knoditionieren, sodass A und C dann unabhängig werden. In der seriellen und der divergenten Struktur blockiert B also den Pfad von A zu C.\n3) Convergent: Die konvergente Struktur\n\n\n\n\n\nAbb. 10: Konvergente Struktur\n\n\n\n\nIn der konvergenten Struktur sind A und C die Parent-Knoten von B. B ist also abhängig von A und von C. Dabei sind A und C zunächst unabhängig voneinander. Die ändert sich jedoch, wenn man auf B konditioniert. Da sowohl A als auch C einen Einfluss auf B ausüben, besteht auch zwischen A und C eine Abhängigkeit sobald ein Wert für B konditioniert wird (da dieser Wert sowohl auf A als auch C basiert). Dies gilt auch für alle potentiellen Child-Knoten von B.\nAuf diese Weise können alle direkten und indirekten Kausalitäten von Variablen in einem BN identifiziert werden. Dazu eignen sich die path.exist() und die dsep()-Funktionen im bnlearn-Paket. Darauf kommen wir später noch einmal zurück.\n\nBeispiel für D-Separation:\nEin einfaches Beispiel für ein besseres Verständnis der D-Seperation liefern Geiger, Verma und Pearl (1990, S. 513, Übersetzung V.B.):\n[…] Wenn jede Variable als Knoten dargestellt wird und Kanten zwischen den Knoten die kausalen Abhängigkeiten der Variablen darstellen, ergibt sich eine grafische Abbildung der kausalen Hierarchie. Ein Beispiel: Die Aussagen “es regnet” (A), “der Gehweg ist nass” (B) und “John ist auf dem Gehweg ausgerutscht” (C) lassen sich durch eine Kette von drei Knoten - von A durch B zu C - abbilden. Es liegt Nahe, dass entweder Regen oder ein nasser Gehweg ursächlich für das Ausrutschen sein können, dennoch wird der nasse Gehweg als kausal ursächlich für das Ausrutschen dargestellt: Regen kann dazu führen, dass jemand auf dem Gehweg ausrutscht - allerdings nicht, wenn der Gehweg überdacht ist.\nErgebnis: Wenn die Kondition des Gehwegs (nass/trocken) bekannt ist, führt dies zu einer Unabhängigkeit der Variablen Regen und Ausrutschen.\n\n\n\n\n\nAbb. 11: Beispiel von Geiger, Verma & Pearl (1990, S. 513)"
  },
  {
    "objectID": "index.html#beispiel-das-asia-netzwerk-1988",
    "href": "index.html#beispiel-das-asia-netzwerk-1988",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "2 Beispiel: Das Asia-Netzwerk (1988)",
    "text": "2 Beispiel: Das Asia-Netzwerk (1988)\nEin sehr bekanntes Beispiel für Bayes’sche Netzwerke ist das Asia-Netzwerk, das auf einem syntethischen Datensatz von Lauritzen und Spiegelhalter (1988) basiert. Der Datensatz ist im bnlearn-Package integriert. Der Datensatz besteht aus 8 Variablen und 5000 Fällen. Die Variablen sind:\n\nD (dyspnoea), eine Zwei-Level Faktorvariable (yes/no)\nT (tuberculosis), eine Zwei-Level Faktorvariable (yes/no)\nL (lung cancer), eine Zwei-Level Faktorvariable (yes/no)\nB (bronchitis), eine Zwei-Level Faktorvariable (yes/no)\nA (visit to Asia), eine Zwei-Level Faktorvariable (yes/no)\nS (smoking), eine Zwei-Level Faktorvariable (yes/no)\nX (chest X-ray), eine Zwei-Level Faktorvariable (yes/no)\nE (tuberculosis versus lung cancer/bronchitis), eine Zwei-Level Faktorvariable (yes/no)\n\nAufgrund der Übersichtlichkeit (wenige Variablen mit wenigen Ausprägungen) wird dieses Beispiel oft als Einstieg in das Thema der Bayes’schen Netzwerke gewählt, obwohl es sich um ein synthetisches Beispiel handelt, das von empirischen Daten nicht bestätigt werden konnte. Die von Lauritzer und Spiegelhalter formulierte Kausalannahme zu diesem Beispiel lautet:\n“Shortness-of-breath (dyspnoea) may be due to tuberculosis, lung cancer or bronchitis, or none of them, or more than one of them. A recent visit to Asia increases the chances of tuberculosis, while smoking is known to be a risk factor for both lung cancer and bronchitis. The results of a single chest X-ray do not discriminate between lung cancer and tuberculosis, as neither does the presence or absence of dyspnoea.” (Lauritzer & Spiegehalter, 1988, S. 163)\n\n&gt; # Asia-Datensatz laden\n&gt; data(asia)\n&gt; \n&gt; # Daten ansehen\n&gt; head(asia, 5)\n\n   A   S   T  L   B   E   X   D\n1 no yes  no no yes  no  no yes\n2 no yes  no no  no  no  no  no\n3 no  no yes no  no yes yes yes\n4 no  no  no no yes  no  no yes\n5 no  no  no no  no  no  no yes\n\n\n\n2.1 Netzwerkstruktur implementieren und Netzwerk anzeigen\nMit der Funktion model2network() können wir die Netwerkstruktur manuell definieren. Dabei werden die einzelnen Kausalzusammenhänge zwischen den Variablen, die im Netzwerk abgebildet werden sollen, jeweils in eckigen Klammern dargestellt.\n\n&gt; # Netzwerkstruktur implementieren\n&gt; dag_asia &lt;- model2network(\"[A][S][T|A][L|S][B|S][D|B:E][E|T:L][X|E]\")\n&gt; \n&gt; # Netzwerkstruktur anzeigen\n&gt; graphviz.plot(dag_asia)\n\n\n\n\nAbb. 12: Das Asia-Netzwerk\n\n\n\n\nDie Schreibweise zur Implementierung der Netzwerkstruktur ist wie folgt: [abhängige Variable | unabhängige Variable] Wenn mehrere Pfeile von oder zu einer Variablen dargestellt werden sollen, können diese durch Doppelpunkte getrennt werden: [abhängige Variable | unabhängige Variable 1 : unabhängige Variable 2].\nDas bnlearn-Paket erlaubt viele weitere Möglichkeiten, die Netzwerkstruktur zu implementieren. Eine Übersicht gibt es hier: https://www.bnlearn.com/examples/dag/\n\n\n2.2 Parameter lernen\nAus der Netzwerkstruktur und den hinterlegten Daten können nun die CPTs errechnet werden. Dies kann manuell passieren. Das bnlearn-Paket hat aber auch eine entsprechende Funktion implementiert. Wir übergeben der Funktion also einfach den Datensatz mit unserem empirischen Daten und bnlearn berechnet die bedingten Wahrscheinlichkeiten dann anhand der empirischen Evidenz mithilfe der bnfit()-Funktion:\n\n&gt; bn_asia &lt;- bn.fit(dag_asia, data = asia, method = \"mle\")\n\nMit dem bn_asia-Objekt können nun die Wahrscheinlichkeiten für bestimmte Kombinationen an Evidenz abgefragt werden. Wenn wir zum Beispiel die Wahrscheinlichkeit dafür wissen wollen, dass ein X-Ray positiv ist und wir wissen bereits, dass die Person raucht, aber in letzter Zeit nicht in Asien war, können wir die Abfrage wie folgt formulieren:\n\n&gt; cpquery(bn_asia, event = (X == \"yes\"), \n+         evidence = ((A == \"no\") & (S == \"yes\")))\n\n[1] 0.1646413\n\n\nDas Event, für das die Wahrscheinlichkeit gesucht wird, ist X==\"yes\" (X-Ray ist positiv) unter der Bedingung, dass A==\"no\" (Person war nicht in Asien) und S==\"yes\" (Person raucht). Die Wahrscheinlichkeit, dass ein X-Ray positiv ist, wenn jemand raucht, aber nicht in Asien war, liegt also bei 17%. Wenn wir wissen, dass die Person zusätzlich in Asien war, erhöht sich die Wahrscheinlichkeit auf 36%:\n\n&gt; cpquery(bn_asia, event = (X == \"yes\"), \n+         evidence = ((A == \"yes\") & (S == \"yes\")))\n\n[1] 0.3529412\n\n\nIn Kapitel 4 schauen wir uns auch an, wie man vorgeht, wenn man die bedingten Wahrscheinlichkeiten manuell berechnen möchte. Das kann zum Beispiel dann hilfreich sein, wenn man Daten aus mehreren Datenquellen miteinander kombinieren möchte und nicht nur einen einzigen Datensatz mit empirischen Daten vorliegen hat."
  },
  {
    "objectID": "index.html#bayessche-netzwerke-erstellen",
    "href": "index.html#bayessche-netzwerke-erstellen",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "3 Bayes’sche Netzwerke erstellen",
    "text": "3 Bayes’sche Netzwerke erstellen\nPrinzipiell gibt es zwei Möglichkeiten, Bayes’sche Netzwerke zu erstellen und Kausalzusammenhänge damit zu analysieren. Die erste Variante ist, das Modell aufgrund theoretischer Annahmen zu erstellen und dann mit Daten zu füttern. Der Ausgangspunkt hier ist also eine Theorie, bzw. eine Annahme über die Variablen, die benötigt werden, um ein Phänomen zu beschreiben und wie diese Variablen zusammenhängen. In der zweiten Variante können Zusammenhänge zwischen Variablen aus empirischen Daten erlernt werden.\n\n3.1 Netzwerkstruktur manuell erstellen (expert systems)\nDieses Vorgehen ist dann geeignet, wenn man eine Annahme darüber hat, wie verschiedene Variablen zusammenhängen könnten und wenn man diese Annahmen anhand von Daten oder Expert:inneneinschätzungen prüfen möchte und die Relevanz der einzelnen Variablen für das Ergebnis berechnen möchte. Dazu werden sowohl die Netzwerkstruktur als auch die bedingten Wahrscheinlichkeiten, mit denen die Netzwerkstruktur unterlegt wird, manuell implementiert. Eine ausführliche Beschreibung für die Umsetzung in R gibt es in Kapitel 4.\n\nBayes’sche Netzwerke als Expert:innensysteme:\nEin großer Vorteil Bayes’scher Netzwerke ist, dass sie als sogenannte Expert:innensysteme fungieren können. Das heißt, dass die angenommene Struktur des Netzwerkes und damit der Kausalzusammenhänge auf Basis der Einschätzung von Expert:innen geschehen kann (z.B. durch Expert:inneninterviews, gemeinsame Workshops, oder bestehende Forschungs- und Datengrundlagen zu einem Thema). Diese Expert:innen können sowohl an der Erarbeitung der Kausalstruktur, also des Netzwerks, beteiligt werden, als auch Einschätzungen zu den bedingten Wahrscheinlichkeiten geben. Damit bieten Bayes’sche Netzwerke großes Potential für die Beteiligung von Stakeholdern in der Planungs- und Umsetzungsphase von Projekten.\nEine Besonderheit ist zudem, dass Daten aus verschiedenen Quellen miteinander kombiniert werden können. Da Bayes’sche Netzwerke CPTs als Input nutzen und die Wahrscheinlichkeiten dieser CPTs dem Modell manuell übergeben werden können (vgl. Kapitel 4), müssen die CPTs für verschiedene Variablen nicht alle aus demselben Datensatz stammen. Es können auch bedingte Wahrscheinlichkeitstabellen aus verschiedenen Datenquellen berechnet werden, wenn diese Datenquellen Zusammenhänge zwischen Variablen beinhalten, die für das vorliegende Kausalmodell relevant sind.\nDies ist zum Beispiel dann sinnvoll, wenn eine Maßnahme oder ein Projekt noch am Anfang der Planung steht, sodass noch keine eigenen Daten erhoben werden konnten. Auch eine Kombination aus Expert:inneneinschätzungen und Sekundärdaten ist möglich.\nNatürlich gilt, wie immer, wenn es um Datenanalysen geht: Die Aussagekraft des Modells ist besser, je besser die Datengrundlage ist.\nDaher ist es ratsam, im Falle von Expert:inneneinschätzungen und/oder Sekundäranalsen im weiteren Verlauf des Projektvorgehens Daten zu sammeln, die sich auf den eigenen, tatschlichen Use Case beziehen, um die Annahmen im Modell auch mit direkter empirischer Evidenz unterlegen und überprüfen zu können. Gerade zu Beginn eines Projektes ist die Arbeit mit Sekundärdaten und Expert:inneneinschätzungen jedoch ein sinnvoller erster Schritt, um zu schauen, welche der theoretischen Annahmen über die Zusammenhänge geplanter Handlungsschritte sinnvoll sind.\n\n\n3.2 Netzwerkstruktur aus Daten lernen (structure learning)\nDie zweite Möglichkeit ist es, die Netzwerkstruktur aus den Daten zu lernen. Diese Variante ist geeignet, wenn empirische Daten zu einem Sachverhalt vorliegen, wenn aber zum Beispiel noch keine genaue Vorstellung davon vorhanden ist, wie diese Daten zusammenhängen könnten. Mit anderen Worten: Anstatt mit einer Idee davon zu starten, wie unterschiedliche Variablen zusammenhängen könnten (z. B. wie in einer Theory of Change), werden die Zusammenhänge und damit die Kanten des Netzwerks aus den Daten erschlossen.\nDer Vorteil besteht darin, dass kein bzw. nur wenig Vorwissen zu einem bestimmten Themenbereich notwendig ist. Der Nachteil besteht darin, dass die Datengrundlage stark darüber entscheidet, wie gut das Modell ist. Wenn etwa relevante Variablen in einem Datensatz fehlen oder Zusammenhänge aufgrund eines Stichproben-Bias nicht abgebildet werden können, wird ein solches Modell keine sinnvollen Ergebnisse liefern können.\nFür die Inferenz der Netzwerkstruktur aus einem vorhandenen Datensatz gibt es verschiedene Algorithmen, die jeweils unterschiedliche Vor- und Nachteile mitbringen. Im bnlearn-Packet sind die folgenden Algorithmen implementiert:\n\nconstraint-based (PC Stable, Grow-Shrink, IAMB, Fast-IAMB, Inter-IAMB, IAMB-FDR, MMPC, Semi-Interleaved HITON-PC, HPC),\nscore-based (hill climbing und tabu search)\nund hybrid (MMHC, H2PC, RSMAX2).\n\nEine ausführliche Erklärung der verschiedenen Algorithmen findet sich in der Dokumentation des bnlearn-Pakets und unter https://www.bnlearn.com/.\nEs ist natürlich auch möglich, zunächst Annahmen über die Kausalzusammenhänge der Variablen auf Basis bestehender Forschung zu formulieren und diese Annahmen dann mit dem erlernten Netzwerk aus den empirischen Daten zu vergleichen. Dies hilft dabei, die theoretischen Annahmen zu überprüfen und zu verbessern."
  },
  {
    "objectID": "index.html#ein-bayessches-netzwerk-am-beispiel-des-e-valuate-projekts-erstellen",
    "href": "index.html#ein-bayessches-netzwerk-am-beispiel-des-e-valuate-projekts-erstellen",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "4 Ein Bayes’sches Netzwerk am Beispiel des E-Valuate-Projekts erstellen",
    "text": "4 Ein Bayes’sches Netzwerk am Beispiel des E-Valuate-Projekts erstellen\nDas Projekt E-Valuate - Auf dem Weg zum lernenden Staat ist ein vom Bundesministerium für Digitales und Verkehr (BMDV) bis Ende 2025 gefördertes Forschungsprojekt. Anhand der Digitalstrategie der Bundesregierung werden Projekte aus der Digitalstrategie in Form von Reallaboren begleitet und Methoden für wirkungsorientiertes Arbeiten erprobt.\nDie zentrale Frage des hier beispielhaft berechneten BNs ist also, welche Faktoren dazu führen, dass Wirkungsorientierung in der Umsetzung eines Projektes implemeniert wird.\nDazu haben wir eine Theory of Change (ToC) erstellt. Die ToC ist ein Wirkungsmodell, dass es erlaubt, die angenommenen Kausalzusammenhänge zwischen einzelnen Handlungsschritten und ihren Ergebnissen als Netzwerkgraph darzustellen. Die Handlungsschritte und Ergebnisse werden dabei jeweils als individuelle Events (Knoten) in des Modell aufgenommen. Die Kausalzusammenhängen werden als Pfeile (Kanten) dargestellt. Eine ToC folgt damit denselben Grundprizipien wie die Darstellung Bayes’scher Netzwerke. Wenn die ToC den Anforderungen folgt, denen Bayes’sche Netzwerke unterliegen (vgl. Kapitel 1), ist sie die ToC eine gute Basis für die Struktur eines BN.\nDie dargestellten Annahmen über die Kausalzusammenhänge der Variablen lauten beispielhaft folgendermaßen: Die Projektart hat einen Einfluss darauf, wie viele Ministerien und externe Organisationen an der Umsetzung des Projekts beteiligt sind (z.B. weil bestimmte Kompetenzen benötigt werden). Wenn mehrere Ministerien und dienstleistende Organisationen an der Projektumsetzung beteiligt sind, hat das einen Einfluss darauf, ob Mitarbeitende praktische Erfahrung mit und theoretisches Wissen über Wirkungsorientierung haben (z. B. weil es bei mehreren Beteiligten wahrscheinlicher ist, dass einige Mitarbeitende schon mit entsprechenden Methoden und Lernmaterialien gearbeitet haben und dies an das restliche Team weitergeben können). Außerdem kann die Nutzung von Wissensressourcen einen direkten Einfluss auf das theoretische Wissen ausüben. Wissen über und Erfahrung mit Wirkungsorientierung bei den Mitarbeitenden beeinflussen schließlich, ob Wirkungsorientierung in Projekten implementiert wird. Die dazugehörige ToC sieht so aus:\n\n\n\nAbb. 13: ToC: Implementierung von Wirkungsorientierung in Projekten (Anmerkung: Die Pfeile stellen angenommene Kausalzusammenhänge zwischen den Variablen dar.)\n\n\nAchtung: Bei der Erstellung einer ToC neigt man manchmal dazu, jeden kleinen Zwischenschritt und seine Auswirkungen auf die anderen Events abbilden zu wollen. Wenn das Ziel ist, die ToC als Basis für ein Bayes’sches Netzwerk zu nutzen, müssen jedoch die Einschränkungen Bayes’scher Netzwerke betrachtet werden. Insbesondere ist wichtig, dass die ToC keine Zirkelschlüsse (Loops) enthält. Mit anderen Worten: An keiner Stelle im Netzwerk dürfen sich Variablen selbst erklären.\nZudem ist es ratsam, darauf zu achten, dass die ToC nicht zu komplex wird. Dies hat vorallem forschungspraktische Gründe. Bayes’sche Netzwerke können prinzipiell gut mit vergleichsweisen großen Datenmengen umgehen, da sie sich auf eine lokale Berechnung der Wahrscheinlichkeiten beschränken (für eine ausfürhliche Erklärung siehe Scutari & Denis, 2022), allerdings muss berücksichtigt werden, dass die CPTs schnell komplex werden, wenn ein Knoten viele Abhängigkeiten (parents) hat.\n\n4.1 Das Netzwerk implementieren\nZunächst müssen wir die Netzwerkstruktur implementieren. Dazu orientieren wir uns an der ToC. Das beispielhafte Modell enthält sieben Variablen:\n\nWirkung: Die Variable misst anhand eines eigens entwickelten Wirkungsindex (Skala: 0-100), ob Wirkungsorientierung in einem Projekt integriert ist. Diese metrische Variable wird zu einer dichotomen Variablen mit den Ausprägungen ja (Wirkungsorientierung ist implementiert) und nein (Wirkungsorientierung ist nicht implementiert) umcodiert. Wirkung = ja wird angenommen, wenn der Wirkungsindex über 50 liegt.\nErfahrung: Die Variable misst, ob die Befragten Mitarbeitenden praktische Erfahrung mit Wirkungsorientierung haben. Es handelt sich um eine dichotome Variable (ja, nein).\nWissen: Die Variable misst, ob die Befragten angeben, dass sie sich bereits mit dem Thema Wirkungsorientierung beschäftigt haben. Es handelt sich um eine dichotome Variable (ja, nein).\nRessourcen: Die Variable misst, ob Wissensressourcen (z. B. Leitfäden, (Online-)Kurse, etc.) über Wirkungsorientierung von den Mitarbeitenden genutzt werden. Es handelt sich um eine dichotome Variable (ja, nein).\nMinisterien: Die Variable misst, ob mehrere Ministerien an der Umsetzung des Projekts berteiligt sind. Es handelt sich um eine dichotome Variable (ja, nein).\nOrganisationen: Die Variable misst, ob externe Organisationen an der Umsetzung beteiligt sind. Es handelt sich um eine kategoriale Variable mit drei Ausprägunge (ja, nein, unklar).\nProjektart: Die Variable gibt an, um welche Art von Projekt es sich handelt. Es handelt sich um eine Faktorvariable mit sechs Ausprägungen (Digitalisierung, Strategie, Förderung, Gesetzgebung, Organisation, Sonstiges).\n\n\nNetzwerkstruktur in R implementieren:\nDie Netzwerkstruktur implementieren wir manuell auf Basis der ToC.\n\n&gt; # Wir definieren die Knoten des Graphen\n&gt; nodes_evaluate = empty.graph(nodes = c(\"wirkung\", \"erfahrung\", \"wissen\", \"ressourcen\", \"ministerien\", \"organisationen\", \"projektart\"))\n&gt; \n&gt; # Dann definieren wir die Netzwerkstruktur, also die Kanten zwischen den Knoten\n&gt; # Achtung: Die Namen der Knoten müssen genau so sein, wie im ersten Schritt definiert\n&gt; dag_evaluate &lt;- model2network(\"[projektart][ressourcen][wirkung|wissen:erfahrung][wissen|ressourcen:organisationen][erfahrung|ministerien:organisationen][ministerien|projektart][organisationen|projektart]\")\n&gt; \n&gt; # Graphen ansehen und mit der ToC vergleichen\n&gt; graphviz.plot(dag_evaluate)\n\n\n\n\nAbb. 14: Das E-Valuate-Netzwerk\n\n\n\n\nEs fällt auf, dass bnlearn die Variablen genau so anordnet, wie in unserer Theory of Change. Die empirischen Datengrundlage ist eine quantitative Onlineumfrage unter Mitarbeitenden der Verwaltung im Kontext der Digitalstrategie, die im April und Mai 2024 durchgeführt wurde.\n\n\n4.2 Modell fit: Das Modell mit Daten füttern\nWenn für alle Variablen des Modells Daten in einem Datensatz vorliegen, können diese dazu genutzt werden, die Wahrscheinlichkeitsverteilungen zu berechnen, mit denen die Kausalbeziehungen im Netzwerk hinterlegt werden.\nZunächst verschaffen wir uns einen Überblick über die Variablen im Datensatz und führen ein paar Bereinigungs- und Vorbereitungsschritte durch.\n\n&gt; # Variablennamen anziegen\n&gt; names(df_bn)\n\n[1] \"projektart\"     \"organisationen\" \"ministerien\"    \"ressourcen\"    \n[5] \"erfahrung\"      \"wissen\"         \"wirkung\"       \n\n&gt; # Übersicht über das Objekt und die Variablenarten mit str()\n&gt; # Alle Variablen müssen factor sein\n&gt; str(df_bn)\n\n'data.frame':   86 obs. of  7 variables:\n $ projektart    : chr  \"Förderung\" \"Gesetzgebung\" \"Gesetzgebung\" \"Strategieentwicklung\" ...\n $ organisationen: chr  \"nein\" \"ja\" \"ja\" \"ja\" ...\n $ ministerien   : chr  \"nein\" \"nein\" \"ja\" \"nein\" ...\n $ ressourcen    : chr  NA \"nein\" NA NA ...\n $ erfahrung     : chr  NA \"ja\" NA NA ...\n $ wissen        : chr  NA \"nein\" NA NA ...\n $ wirkung       : chr  \"ja\" \"ja\" \"nein\" \"nein\" ...\n\n&gt; # NAs behandeln wir in diesem Fall wie \"nein\"-Antworten\n&gt; df_bn[is.na(df_bn)] &lt;- \"nein\"\n&gt; \n&gt; # chr-Variablen zu factor-Variablen\n&gt; # Linke Seite der Zuweisung identifiziert alle Variablen im df, die chr sind\n&gt; # sapply links ist notwendig, damit das Objekt ein df und keine Liste ist\n&gt; # Rechte Seite führt as.factor für jede chr-Variable aus\n&gt; df_bn[sapply(df_bn, is.character)] &lt;- lapply(df_bn[sapply(df_bn, is.character)], \n+                                        as.factor)\n\nFür die Berechnung der konditionellen Wahrscheinlichkeiten aus den vorliegenden empirischen Daten nutzen wir dann die bnfit-Funktion aus bnlearn:\n\n&gt; # bn.fit-Fuktion\n&gt; bn_mle &lt;- bn.fit(dag_evaluate, data = df_bn, method = \"mle\")\n\n\n\n4.3 CPTs manuell berechnen\nEs ist auch möglich, die CPTs selbst zu berechnen und einzeln an das Modell zu übergeben. Das ist dann hilfreich, wenn diverse Datengrundlagen miteinander kombiniert werden sollen. Beispielhaft machen wir das hier für eine Variable.\nAchtung: Dies ist eine Alternative zur Berechnung über die bn.fit()-Funktion. Diese Schritte sind nicht notwendig, wenn alle Variablen in einem Datensatz vorliegen.\nDie Formel für bedingte Wahrscheinlichkeiten lautet:\nP(B | A) = P(A and B) / P(A) .\nIn R berechnen wir bedingte Wahrscheinlichkeiten ganz einfach mit der prop.table()-Funktion aus Base R.\n\n# Berechnung der CPTs mit der prop.table()-Funktion in Base-R für Eltern-Knoten\ncpt_projektart &lt;- prop.table(table(df_bn[, \"projektart\"]))\n\n# Für Zusammenhänge mehrerer Knoten\n# Wir setzen margin=1, damit die Wahrscheinlichkeiten abhängig von der ersten Variable (Ressourcen) berechnet werden\ncpt_wiss_ress &lt;- prop.table(table(df_bn[, c(\"ressourcen\", \"wissen\")]), margin = 1)\n\n# Für mehr als zwei Knoten\ncpt_wiss_ress &lt;- prop.table(table(df_bn[, c(\"wissen\", \"ressourcen\")]), margin = 1)\n\n\nExpert:inneneinschätzungen:\nWenn die Wahrscheinlichkeiten auf Expert:inneneinschätzungen beruhen, kann man die CPTs als Matrix selbst aufsetzen (Achtung: die Wahrscheinlichkeit hier sind nur ein Beispiel und entsprechen nicht den tatsächlichen Werten):\n\n# Für die Parent-Variablen sind die Tabellen klein\ncpt_ressourcen &lt;- matrix(c(0.4, 0.6), ncol = 2, dimnames = list(NULL, c(\"Ja\", \"Nein\")))\n\n# Für zwei Variablen und mehrere Kategoren wird es etwas komplexer\ncpt_ministerien &lt;- array(c(0.4, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.2, 0.2, 0.1, 0.1, 0.1, 0.1, 0.1), dim = c(7,2), dimnames = list(\"projektart\" = c(\"Digitalisierung\", \"Förderung\", \"Gesetzgebung\", \"IT-Entwicklung\", \"Organisationsmaßnahme\", \"Sonstiges\", \"Strategientwicklung\"), \"ministerien\" = c(\"ja\", \"nein\")))\n\n# Für drei Variablen muss die dim-Option entsprechend angepasst werden\ncpt_erfahrung &lt;- array(c(0.5, 0.5, 0.4, 0.6, 0.3, 0.7, 0.2, 0.8), dim = c(2, 2, 2), dimnames = list(\"erfahrung\" = c(\"ja\", \"nein\"), \"ministerien\" =  c(\"Ja\", \"Nein\"), \"organisationen\" = c(\"ja\", \"nein\")))\n\n\ncustom.fit()-Funktion:\nWenn die CPTs manuell berechnet oder auf Basis von Expert:inneneinschätzungen angelegt wurden, nutzen wir zum übertragen in das Modell die custom.fit- statt der bn.fit-Funktion aus dem bnlearn-Paket:\n\n# Wir übergeben alle lokalen Verteilungen (CPTs) an eine Liste, die wir in custom.fit() einlesen können\n\n# Die Tabellen werden den entsprechenden Knotennamen zugeordneten, damit bnlearn die Wahrscheinlichkeiten zuordnen kann\ncpts_evaluate &lt;- list(ressourcen = cpt_ressourcen, ministerien = cpt_ministeiren, erfahrung = cpt_erfahrung) #usw.\n\n# BN berechnen\nbn_custom &lt;- custom.fit(dag_evaluate, cpts_evaluate)\n\n\n\n4.4 Modellübersicht\nIm fertigen bn.fit-Objekt (entweder aus der bn.fit oder der custom.fit-Funktion) sind die Kausalannahmendes DAGs nun mit Daten hinterlegt, sodass wir verschiedene Arten von Abfragen an das Modell stellen können.\nDie Funktion nparams() gibt die Anzahl der Parameter im Modell aus:\n\n&gt; nparams(bn_mle)\n\n[1] 44\n\n\nDie Funktion arcs() zeigt die Pfeile des Netzwerks in Form einer Kantenliste an:\n\n&gt; arcs(bn_mle)\n\n     from             to              \n[1,] \"erfahrung\"      \"wirkung\"       \n[2,] \"ministerien\"    \"erfahrung\"     \n[3,] \"organisationen\" \"erfahrung\"     \n[4,] \"organisationen\" \"wissen\"        \n[5,] \"projektart\"     \"ministerien\"   \n[6,] \"projektart\"     \"organisationen\"\n[7,] \"ressourcen\"     \"wissen\"        \n[8,] \"wissen\"         \"wirkung\"       \n\n\nEine Übersicht über weitere Befehle gibt es hier: https://www.bnlearn.com/documentation/bnlearn-manual.pdf\n\nExact Inference:\nFür die genaue Berechnung der Wahrscheinlichkeiten für das Eintreten bestimmter Events unter der Berücksichtigung anderer Variablen im Netzwerk ist das gRain-Paket notwendig. Das Bayes’sche Netzwerk wird dazu zunächst in einen junction tree, also eine Baumstruktur, überführt.\n\n&gt; library(gRain)\n&gt; \n&gt; # BN zu junction tree \n&gt; junction &lt;- compile(as.grain(bn_mle))\n\nAnschließend lassen sich die Wahrscheinlichkeiten bestimmter Knoten abfragen.\n\n&gt; q &lt;- gRain::querygrain(junction, nodes = \"wirkung\")\n&gt; q$wirkung\n\nwirkung\n       ja      nein \n0.6311622 0.3688378 \n\n\nEs lassen sich auch Evidenzen für bestimmte Variablen festlegen. So lässt sich zum Beispiel die Wahrscheinlichkeit für wirkung = ja abfragen, wenn es sich um ein Digitalisierungsprojekt handelt:\n\n&gt; # Dazu setzen wir zunächst die Werte fest, die abgefragt werden sollen\n&gt; junction_digi &lt;- gRain::setEvidence(junction, nodes = \"projektart\", states = \"Digitalisierung\" )\n&gt; \n&gt; # Danach können wir die Wahrscheinlichkeit wie oben abfragen\n&gt; q &lt;- gRain::querygrain(junction_digi, nodes = \"wirkung\")\n&gt; q$wirkung\n\nwirkung\n       ja      nein \n0.6334746 0.3665254 \n\n\n\nApproximate Inference:\nAlternativ können Monte Carlo-Simulationen genutzt werden, um Schätzungen über die Wahrscheinlichekiten für das Eintreten bestimmter Ereignisse zu machen. Dazu werden zunächst auf Basis der Daten Beobachtungen simuliert, aus diese wird dann die Wahrscheinlichkeit für ein bestimmtes Ereignis geschätzt. Bei Monte Carlo-Simulationen werden wiederholt Zufallsstichproben einer Verteilung generiert.\nDies ist im cpquery-Befehl des bnlearn-Pakets implementiert. Approximate Inference ist vor allem dann sinnvoll, wenn die Fallzahl der empirischen Daten gering ist oder wenn es sich um Expert:inneneinschätzungen handelt. Hier ein paar Beispiele für unterschiedliche Abfragen:\n\n&gt; # in bnlearn enthalten\n&gt; cpquery(bn_mle, event = (wirkung == \"ja\"), \n+         evidence = ((wissen == \"ja\") & (erfahrung == \"ja\")))\n\n[1] 0.6203032\n\n&gt; cpquery(bn_mle, event = (wirkung == \"ja\"), \n+         evidence = ((wissen == \"nein\") & (erfahrung == \"nein\")))\n\n[1] 0.04748201\n\n&gt; cpquery(bn_mle, event = (wirkung == \"ja\"), \n+         evidence = ((wissen == \"nein\") & (erfahrung == \"ja\")))\n\n[1] 0.844914\n\n&gt; cpquery(bn_mle, event = (wirkung == \"ja\"), \n+         evidence = ((projektart == \"Digitalisierung\") & (erfahrung == \"nein\")))\n\n[1] 0.05432596\n\n&gt; cpquery(bn_mle, event = (erfahrung == \"ja\"), \n+         evidence = ((ressourcen == \"nein\")))\n\n[1] 0.7774162\n\n&gt; cpquery(bn_mle, event = (wissen == \"ja\"), \n+         evidence = ((ressourcen == \"nein\")))\n\n[1] 0.2549871\n\n&gt; cpquery(bn_mle, event = (wissen == \"ja\"), \n+         evidence = ((ressourcen == \"nein\")))\n\n[1] 0.2504484\n\n\nWir müssen berücksichtigen, dass es sich um Schätzungen handelt. Bei wiederholter Abfrage derselben Variablen können also leicht unterschiedliche Werte herauskommen. Zudem werden die Wahrscheinlichkeiten leicht von der exakten Abfrage mit dem gRain-Paket (siehe oben) abweichen.\nDie Genauigkeit der Schätzung kann verbessert werden, indem die Fallzahl (n) erhöht wird. Allerdings führt dies zu sehr langen Rechenzeiten. Eine bessere Option ist das likelihood weighting, das im cpquery-Paket über die Option method=\"lw\" implementiert ist: “Likelihood weighting generates random observations in such a way that all of them match the evidence, and re-weights them appropriately when computing the conditional probability for the query.” (Scutari & Denis, 2022, S. 27)\n\n&gt; cpquery(bn_mle, event = (wirkung == \"ja\"), evidence = list(wissen = \"nein\"), method = \"lw\")\n\n[1] 0.6510745\n\n\nAchtung: Wenn method=lw gesetzt wird, gibt es die Besonderheit, dass evidence als Liste übergeben werden muss. Wir müssen hier also den list()-Befehl ergänzen wie oben geschehen.\nDie simulierten Beobachtungen können mithilfe des cpdist-Befehls auch in einen Datensatz überführt werden. Dieser Ansatz ist extrem hilfreich, um etwa simulierte Daten für Expert:inneneinschätzungen zu generieren. Auf der Basis der so generierten Daten können dann weitere Analysen durchgeführt werden, um Annahmen über die Daten zu prüfen.\n\n&gt; # Datensatz simulieren\n&gt; simulated_df &lt;- cpdist(bn_mle, nodes=c(\"wirkung\", \"wissen\", \"ressourcen\"), evidence= (erfahrung == \"ja\"))\n&gt; \n&gt; # Erste 5 Fälle des df ansehen\n&gt; head(simulated_df, 5)\n\n  wirkung wissen ressourcen\n1      ja     ja         ja\n2      ja   nein       nein\n3      ja   nein       nein\n4      ja   nein         ja\n5    nein     ja         ja"
  },
  {
    "objectID": "index.html#bns-visualisieren",
    "href": "index.html#bns-visualisieren",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "5 BNs visualisieren",
    "text": "5 BNs visualisieren\nFür eine prägnante Darstellung lassen sich die Ergebnisse in die Netzwerkabbildung integrieren. Dazu bietet das bnlearn-Paket viele praktische Lösungen und Anspassungsmöglichkeiten, die die Umsetzung einfach machen.\nDie einfachste Möglicheit stellt der Befehl graphviz.chart() dar:\n\n&gt; # Für den Default-Plot übergeben wir nur das bn.fit-Objekt an die graphviz-Funktion\n&gt; graphviz.chart(bn_mle)\n\n\n\n\nAbb. 15: Fertiges BN mit Datenvisualisierung als Balkendiagramm\n\n\n\n\nDie Funktion liefert ein Netzwerk, in dem die Knoten als einfache Balkendiagramme dargestellt sind. Um die Daten in den Diagrammen übersichtlicher darzustellen, gibt es verschiedene optionale Argumente in graphviz.chart(). Mit type = \"barprop\" können beispielsweise die Werte angezeigt werden.\n\n&gt; graphviz.chart(bn_mle, type = \"barprob\")\n\n\n\n\nAbb. 16: Fertiges BN mit Datenvisualisierung als Balkendiagramm mit angezeigten Werten\n\n\n\n\nAuch farbliche Anpassungen sind möglich. Das Argument bar.col=\"\" bestimmt die Farbe der Balken und mit dem Argument strip.bg=\"\" kann die Kopfzeile der Diagramme farblich angepasst werden. Das Argument grid=TRUE kann genutzt werden, um vertikale Hilfslinien hinzuzufügen, die das Ablesen der Diagramme erleichtern. Mit der Default-Einstellung grid=TRUE werden diese Linien bei 0, 25, 50, und 75% eingefügt. Durch Angabe eines Vektors mit Dezimalzahlen (z.B. grid=c(0.2, 0.4, 0.6, 0.8)) ist es aber auch möglich, die Linien an individuellen Werten zu platzieren.\n\n&gt; graphviz.chart(bn_mle, type = \"barprob\", grid = TRUE, \n+                bar.col = \"violet\", strip.bg = \"lightskyblue\")\n\n\n\n\nAbb. 17: Fertiges BN mit Datenvisualisierung als Balkendiagramm mit angezeigten Werten und Farben"
  },
  {
    "objectID": "index.html#weiterführende-quellen",
    "href": "index.html#weiterführende-quellen",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "Weiterführende Quellen",
    "text": "Weiterführende Quellen\n\nTheorie Bayes’scher Netzwerke:\nGeiger, D., Verma, T., & Pearl, J. (1990). Identifying independence in Bayesian networks. Networks, 20(5), 507-534. http://ftp.cs.ucla.edu/pub/stat_ser/r116.pdf\nYang, X.-S., (2019). Introduction to Algorithms for Data Mining and Machine Learning. Academic Press.\nbnlearn-Paket:\nBeispiele für die Nutzung von bnlearn: https://www.bnlearn.com/examples/dag/\nDokumentation des bnlearn-Pakets: https://www.bnlearn.com/documentation/bnlearn-manual.pdf"
  },
  {
    "objectID": "index.html#referenzen",
    "href": "index.html#referenzen",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "Referenzen",
    "text": "Referenzen\nGeiger, D., Verma, T., & Pearl, J. (1990). Identifying independence in Bayesian networks. Networks, 20(5), 507-534. http://ftp.cs.ucla.edu/pub/stat_ser/r116.pdf\nLauritzen S., Spiegelhalter D. (1988). Local Computation with Probabilities on Graphical Structures and their Application to Expert Systems (with discussion). Journal of the Royal Statistical Society: Series B, 50(2): 157–224.https://www.eecis.udel.edu/~shatkay/Course/papers/Lauritzen1988.pdf\nScutari, M., & Denis, J.-B., (2022). Bayesian Networks: With Examples in R. CRC Press.\nYang, X.-S., (2019). Introduction to Algorithms for Data Mining and Machine Learning. Academic Press."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Das Projekt",
    "section": "",
    "text": "Text"
  },
  {
    "objectID": "about.html#publikationen",
    "href": "about.html#publikationen",
    "title": "About",
    "section": "Publikationen",
    "text": "Publikationen"
  },
  {
    "objectID": "about.html#e-valuate---auf-dem-weg-zum-lernenden-staat",
    "href": "about.html#e-valuate---auf-dem-weg-zum-lernenden-staat",
    "title": "About",
    "section": "",
    "text": "Text"
  },
  {
    "objectID": "team.html",
    "href": "team.html",
    "title": "Das Team",
    "section": "",
    "text": "Text"
  },
  {
    "objectID": "team.html#benedikt-göller",
    "href": "team.html#benedikt-göller",
    "title": "Das Team",
    "section": "",
    "text": "Text"
  },
  {
    "objectID": "team.html#dr.-vivien-benert",
    "href": "team.html#dr.-vivien-benert",
    "title": "Das Team",
    "section": "Dr. Vivien Benert",
    "text": "Dr. Vivien Benert\nVivien Benert ist Data Scientist und promovierte Kommunikationswissenschaftlerin. Sie arbeitet seit September 2023 bei der Agora Digitale Transformation. Zuvor hat sie als Wissenschaftlerin an der Freien Universität Berlin und am Weizenbaum Institut geforscht.\nInhaltliche Schwerpunkte ihrer Arbeit umfassen die Rolle sozialer Medien für politische Kommunikation und demokratische Legitmation, Transnationale Kommunikation und digitale Netzwerköffentlichkeiten, Kommunikation rechter und anti-demokratischer Akteure in digitalen Netzwerköffentlichkeiten und Wirkungsorientierung und evidenzbasierte Politikgestaltung. Ihre methodischen Schwerpunkte liegen auf den Aspekten Methoden der empirischen Sozialforschung und Statistik, Netzwerktheorie, Netzwerkanalyse und Bayes’sche Netzwerke, Natural Language Processing und automatisierte Textverarbeitung."
  },
  {
    "objectID": "team.html#carolina-gironés-fraile",
    "href": "team.html#carolina-gironés-fraile",
    "title": "Das Team",
    "section": "Carolina Gironés-Fraile",
    "text": "Carolina Gironés-Fraile\nText"
  },
  {
    "objectID": "team.html#felix-kube",
    "href": "team.html#felix-kube",
    "title": "Das Team",
    "section": "Felix Kube",
    "text": "Felix Kube\nText"
  },
  {
    "objectID": "team.html#tim-grave",
    "href": "team.html#tim-grave",
    "title": "Das Team",
    "section": "Tim Grave",
    "text": "Tim Grave\nText"
  },
  {
    "objectID": "bbn.html",
    "href": "bbn.html",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "",
    "text": "Bayes’sche Netzwerke (BN), auch Bayes’sche Netze genannt, sind graphische Modelle der Kausalannahmen zwischen Variablen. Durch das hinterlegen des Modells mit bedingten Wahrscheinlichkeiten für jede Kausalbeziehung lassen sich die kausalen Abhängigkeiten zwischen einzelnen Variablen im Modell besser darstellen als bspw. bei einer multiplen Regression. Zudem kann das Modell auf bestimmte Werte für einzelne Variablen konditioniert werden und die Auswrikung dieser Veränderung auf die anderen Variablen im Modell lassen sich berechnen.\nFür die Berechnung und Darstellung Bayes’scher Netzwerke in R gibt es eine ganze Reihe an Paketen. Im folgenden Arbeiten wir mit den folgenden Paketen:\n\nbnlearn ist ein Paket von Marco Scutari zum Erlernen der grafischen Struktur von Bayes’schen Netzwerken, zum Schätzen ihrer Parameter und zum Durchführen probabilistischer und kausaler Inferenz.\ngRain ist ein Paket für Wahrscheinlichkeitsausbreitung in grafischen Unabhängigkeitsnetzwerken (dazu zählen auch Bayes’sche Netzwerke).\nigraph ist ein Paket für Netzwerkanalysen und Visualisierungen.\n\n\n&gt; # Pakete laden\n&gt; library(bnlearn)\n&gt; library(gRain)\n&gt; library(igraph)\n\nDie Kausalannahmen eines theoretischen Modells werden als Netzwerk dargestellt, in dem die Zufallsvariablen die Knoten darstellen und der angenommene Kausalzusammenhang zwischen mindestens zwei Variablen als ein Pfeil abgebildet wird. Diese Pfeile werden Kanten genannt. Die Pfeilrichtung entspricht dabei der angenommenen Kausalrichtung.\nEs ist auch möglich, dass zwei Knoten in einem Netzwerk durch eine Kante ohne Pfeilspitze verbunden sind. In diesem Fall handelt es sich um ein ungerichtetes Netzwerk, die Richtung der Beziehung zwischen den Knoten ist also nicht klar. Netzwerke, in denen die Richtung der Kanten durch Pfeile angegeben sind, heißen gerichtete Netzwerke. Für Kausalanalysen sind immer gerichtete Netzwerke notwendig, da die angenommenene Richtung des Kausaleinflusses zwischen zwei Variablen klar sein muss.\nHier ein ganz simples Beispiel für ein gerichtetes Netzwerk:\n\n\n\n\n\nAbb. 1: Ein einfacher, gerichteter Graph mit zwei Knoten und einer Kante\n\n\n\n\n\n\nBayes’sches Netzwerk: Ein Bayes’sches Netz ist ein graphical model for representing knowledge about an uncertain domain where each node corresponds to a random variable and each edge represents the conditional probability for the corresponding random variables (Yang, 2019, S. 35). Bayes’sche Netzwerke basieren auf zwei zentralen Konzepten: den DAGs (Directed Acyclic Grpahs) und den bedingten Wahrscheinlichkeitstabellen (Conditional Probability Tables oder CPTs).\nDAGs: Die Abkürzung DAG steht für “Directed Acyclic Graphs”, also gerichtete Netzwerke ohne Zirkelschlüsse. Die Kausalannahmen eines theoretischen Modells werden in Form eines Netzwerkes dargstellt. Um daraus inferenzstatistische Schlüsse ziehen zu können, werden die Variablen, die die Knoten des Netzwerks bilden, mit Variablen und empirischen Daten hinterlegt (vgl. dazu die Abschnitte 2 und 4).\nBedingte Wahrscheinlichkeitstabellen: Bedingte Wahrscheinlichkeitstabellen (Conditional Probability Tables) geben die Wahrscheinlichkeiten der im Modell vorhandenen Variablen an. Bedingte Wahrscheinlichkeiten geben die Wahrscheinlichkeit einer Variable in Abhängigkeit einer anderen Variable an. Wie bedingte Wahrscheinlichkeitstabellen berechnet werden können, schauen wir uns in Kapitel X genauer an.\n\n\n\n\nNetzwerkgraphen sind die grafische Darstellung der Kausalbeziehungen zwischen Variablen. Sie bilden das theoretische Modell der Zusammenhänge zwischen den untersuchten Variablen ab. Sie müssen ein paar Bedingungen erfüllen:\n1) Der Graph muss gerichtet sein, d.h. die Kausalannahmen zwischen den Variablen sind durch die Pfeilrichtungen im Netzwerk dargstellt.\nSo einen Graphen kennen wir bereits:\n\n\n\n\n\nAbb. 2: Ein einfacher, gerichteter Graph\n\n\n\n\n2) Der Netzwerkgraph darf keine Loops enthalten.\n\n\n\n\n\nAbb. 3: Ein Graph mit Selbstreferenz (Loop) des Knotens A\n\n\n\n\nEin Loop ist eine Kante, die von einem Konten auf sich selbst verweist. Im Rahmen von Bayes’schen Netzwerken, in denen die Knoten für Variablen und die Kanten für Kausalbeziehungen zwischen den Variablen stehen, würde ein Loop bedeuten, dass sich eine Variable selbst erklärt. Das widerspricht den grundsätzlichen Annahmen Bayes’scher Netzwerke, auch wenn eine solche Situation theoretisch möglich ist (z. B. wenn man annimmt, dass Menschen mit viel Vermögen mehr Vermögen ansammeln, zum Beispiel durch Kapitalanlagen und Zinseszinseffekte, sodass man stark vereinfacht annehmen könnte, dass das Vermögen sich selbst beeinflusst).\n3) Der Graph muss azyklisch sein.\n\n\n\n\n\nAbb. 4: Ein zyklischer Graph\n\n\n\n\nAchtung: Hier kommt es auf die Richtung der Pfeile an. Bei dieser Variante handelt es sich NICHT um einen zyklischen Graphen:\n\n\n\n\n\nAbb. 5: Ein azyklischer Graph\n\n\n\n\n\n\n\nUm Bayes’sche Netzwerke (BN) besser zu verstehen, müssen wir uns mit ein paar Begrifflichkeiten vertraut machen. Die Kausalbeziehungen im Netzwerk werden durch das Verhältnis der Knoten zueinander dargestellt. Dazu wird in der Netzwerkliteratur der Vergleich mit Verwandschaftsbeziehungen genutzt. Die abhänigen Variablen im Netzwerk werden daher als “children” (Kinder) der unabhängigen Variablen (“parents”, Eltern) bezeichnet.\nIn einem simplen BN mit A –&gt; B wäre A also der Parent und B das Kind (Child).\n\n\n\n\n\nAbb. 6: Eltern- und Kind-Knoten in einem einfachen Graphen\n\n\n\n\nIn einem etwas komplexeren Graphen können Knoten auch mehrere parents (grün) sowie children (grau) haben.\n\n\n\n\n\nAbb. 7: Graph mit mehreren Eltern- und Kind-Knoten\n\n\n\n\n\n\n\nDAGs können immer in drei fundamentale Strukturen zerlegt werden, die die Grundlage für die sogenannte D-Seperation bilden. D-Seperation ist ein zentrales Konzept in Bayes’schen Netzwerken für die Überprüfung der Abhängigkeit oder Unabhängigkeit von zwei Variablen.\n1) Serial: Die serielle Struktur\n\n\n\n\n\nAbb. 8: Serielle Struktur\n\n\n\n\nIn der seriellen Struktur besteht ein Kausalzusammenhang von A zu B und von B zu C. B fungiert also als Mediatorvariable des Einflusses von A auf C. Im Kontext der D-Separation sind A und C somit zunächst - indirekt - abhängig voneinander. Wenn man jedoch auf B konditioniert, blockiert B den Weg von A zu C und diese werden unabhängig voneinander. Mit anderen Worten: Wenn für B ein bestimmter Zustand festgelegt wird, für den der Einfluss auf C berechnet werden soll, wird der Zustand von A irrelevant für die Berechnung der Wahrscheinlichkeit von C.\n2) Divergent: Die divergente Struktur\n\n\n\n\n\nAbb. 9: Divergente Struktur\n\n\n\n\nIn der divergenten Struktur sind A und C Child-Knoten von B. B beeinflusst also sowohl A als auch C. In der D-Seperation sind A und C zunächst abhängig voneinander. Dies ändert sich jedoch, wenn man auf B konditioniert: B blockiert den Pfad von A zu C, wenn wir auf B knoditionieren, sodass A und C dann unabhängig werden. In der seriellen und der divergenten Struktur blockiert B also den Pfad von A zu C.\n3) Convergent: Die konvergente Struktur\n\n\n\n\n\nAbb. 10: Konvergente Struktur\n\n\n\n\nIn der konvergenten Struktur sind A und C die Parent-Knoten von B. B ist also abhängig von A und von C. Dabei sind A und C zunächst unabhängig voneinander. Die ändert sich jedoch, wenn man auf B konditioniert. Da sowohl A als auch C einen Einfluss auf B ausüben, besteht auch zwischen A und C eine Abhängigkeit sobald ein Wert für B konditioniert wird (da dieser Wert sowohl auf A als auch C basiert). Dies gilt auch für alle potentiellen Child-Knoten von B.\nAuf diese Weise können alle direkten und indirekten Kausalitäten von Variablen in einem BN identifiziert werden. Dazu eignen sich die path.exist() und die dsep()-Funktionen im bnlearn-Paket. Darauf kommen wir später noch einmal zurück.\n\nBeispiel für D-Separation:\nEin einfaches Beispiel für ein besseres Verständnis der D-Seperation liefern Geiger, Verma und Pearl (1990, S. 513, Übersetzung V.B.):\n[…] Wenn jede Variable als Knoten dargestellt wird und Kanten zwischen den Knoten die kausalen Abhängigkeiten der Variablen darstellen, ergibt sich eine grafische Abbildung der kausalen Hierarchie. Ein Beispiel: Die Aussagen “es regnet” (A), “der Gehweg ist nass” (B) und “John ist auf dem Gehweg ausgerutscht” (C) lassen sich durch eine Kette von drei Knoten - von A durch B zu C - abbilden. Es liegt Nahe, dass entweder Regen oder ein nasser Gehweg ursächlich für das Ausrutschen sein können, dennoch wird der nasse Gehweg als kausal ursächlich für das Ausrutschen dargestellt: Regen kann dazu führen, dass jemand auf dem Gehweg ausrutscht - allerdings nicht, wenn der Gehweg überdacht ist.\nErgebnis: Wenn die Kondition des Gehwegs (nass/trocken) bekannt ist, führt dies zu einer Unabhängigkeit der Variablen Regen und Ausrutschen.\n\n\n\n\n\nAbb. 11: Beispiel von Geiger, Verma & Pearl (1990, S. 513)"
  },
  {
    "objectID": "bbn.html#einführung-bayessche-netzwerke-und-directed-acyclic-graphs",
    "href": "bbn.html#einführung-bayessche-netzwerke-und-directed-acyclic-graphs",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "",
    "text": "Bayes’sche Netzwerke (BN), auch Bayes’sche Netze genannt, sind graphische Modelle der Kausalannahmen zwischen Variablen. Durch das hinterlegen des Modells mit bedingten Wahrscheinlichkeiten für jede Kausalbeziehung lassen sich die kausalen Abhängigkeiten zwischen einzelnen Variablen im Modell besser darstellen als bspw. bei einer multiplen Regression. Zudem kann das Modell auf bestimmte Werte für einzelne Variablen konditioniert werden und die Auswrikung dieser Veränderung auf die anderen Variablen im Modell lassen sich berechnen.\nFür die Berechnung und Darstellung Bayes’scher Netzwerke in R gibt es eine ganze Reihe an Paketen. Im folgenden Arbeiten wir mit den folgenden Paketen:\n\nbnlearn ist ein Paket von Marco Scutari zum Erlernen der grafischen Struktur von Bayes’schen Netzwerken, zum Schätzen ihrer Parameter und zum Durchführen probabilistischer und kausaler Inferenz.\ngRain ist ein Paket für Wahrscheinlichkeitsausbreitung in grafischen Unabhängigkeitsnetzwerken (dazu zählen auch Bayes’sche Netzwerke).\nigraph ist ein Paket für Netzwerkanalysen und Visualisierungen.\n\n\n&gt; # Pakete laden\n&gt; library(bnlearn)\n&gt; library(gRain)\n&gt; library(igraph)\n\nDie Kausalannahmen eines theoretischen Modells werden als Netzwerk dargestellt, in dem die Zufallsvariablen die Knoten darstellen und der angenommene Kausalzusammenhang zwischen mindestens zwei Variablen als ein Pfeil abgebildet wird. Diese Pfeile werden Kanten genannt. Die Pfeilrichtung entspricht dabei der angenommenen Kausalrichtung.\nEs ist auch möglich, dass zwei Knoten in einem Netzwerk durch eine Kante ohne Pfeilspitze verbunden sind. In diesem Fall handelt es sich um ein ungerichtetes Netzwerk, die Richtung der Beziehung zwischen den Knoten ist also nicht klar. Netzwerke, in denen die Richtung der Kanten durch Pfeile angegeben sind, heißen gerichtete Netzwerke. Für Kausalanalysen sind immer gerichtete Netzwerke notwendig, da die angenommenene Richtung des Kausaleinflusses zwischen zwei Variablen klar sein muss.\nHier ein ganz simples Beispiel für ein gerichtetes Netzwerk:\n\n\n\n\n\nAbb. 1: Ein einfacher, gerichteter Graph mit zwei Knoten und einer Kante\n\n\n\n\n\n\nBayes’sches Netzwerk: Ein Bayes’sches Netz ist ein graphical model for representing knowledge about an uncertain domain where each node corresponds to a random variable and each edge represents the conditional probability for the corresponding random variables (Yang, 2019, S. 35). Bayes’sche Netzwerke basieren auf zwei zentralen Konzepten: den DAGs (Directed Acyclic Grpahs) und den bedingten Wahrscheinlichkeitstabellen (Conditional Probability Tables oder CPTs).\nDAGs: Die Abkürzung DAG steht für “Directed Acyclic Graphs”, also gerichtete Netzwerke ohne Zirkelschlüsse. Die Kausalannahmen eines theoretischen Modells werden in Form eines Netzwerkes dargstellt. Um daraus inferenzstatistische Schlüsse ziehen zu können, werden die Variablen, die die Knoten des Netzwerks bilden, mit Variablen und empirischen Daten hinterlegt (vgl. dazu die Abschnitte 2 und 4).\nBedingte Wahrscheinlichkeitstabellen: Bedingte Wahrscheinlichkeitstabellen (Conditional Probability Tables) geben die Wahrscheinlichkeiten der im Modell vorhandenen Variablen an. Bedingte Wahrscheinlichkeiten geben die Wahrscheinlichkeit einer Variable in Abhängigkeit einer anderen Variable an. Wie bedingte Wahrscheinlichkeitstabellen berechnet werden können, schauen wir uns in Kapitel X genauer an.\n\n\n\n\nNetzwerkgraphen sind die grafische Darstellung der Kausalbeziehungen zwischen Variablen. Sie bilden das theoretische Modell der Zusammenhänge zwischen den untersuchten Variablen ab. Sie müssen ein paar Bedingungen erfüllen:\n1) Der Graph muss gerichtet sein, d.h. die Kausalannahmen zwischen den Variablen sind durch die Pfeilrichtungen im Netzwerk dargstellt.\nSo einen Graphen kennen wir bereits:\n\n\n\n\n\nAbb. 2: Ein einfacher, gerichteter Graph\n\n\n\n\n2) Der Netzwerkgraph darf keine Loops enthalten.\n\n\n\n\n\nAbb. 3: Ein Graph mit Selbstreferenz (Loop) des Knotens A\n\n\n\n\nEin Loop ist eine Kante, die von einem Konten auf sich selbst verweist. Im Rahmen von Bayes’schen Netzwerken, in denen die Knoten für Variablen und die Kanten für Kausalbeziehungen zwischen den Variablen stehen, würde ein Loop bedeuten, dass sich eine Variable selbst erklärt. Das widerspricht den grundsätzlichen Annahmen Bayes’scher Netzwerke, auch wenn eine solche Situation theoretisch möglich ist (z. B. wenn man annimmt, dass Menschen mit viel Vermögen mehr Vermögen ansammeln, zum Beispiel durch Kapitalanlagen und Zinseszinseffekte, sodass man stark vereinfacht annehmen könnte, dass das Vermögen sich selbst beeinflusst).\n3) Der Graph muss azyklisch sein.\n\n\n\n\n\nAbb. 4: Ein zyklischer Graph\n\n\n\n\nAchtung: Hier kommt es auf die Richtung der Pfeile an. Bei dieser Variante handelt es sich NICHT um einen zyklischen Graphen:\n\n\n\n\n\nAbb. 5: Ein azyklischer Graph\n\n\n\n\n\n\n\nUm Bayes’sche Netzwerke (BN) besser zu verstehen, müssen wir uns mit ein paar Begrifflichkeiten vertraut machen. Die Kausalbeziehungen im Netzwerk werden durch das Verhältnis der Knoten zueinander dargestellt. Dazu wird in der Netzwerkliteratur der Vergleich mit Verwandschaftsbeziehungen genutzt. Die abhänigen Variablen im Netzwerk werden daher als “children” (Kinder) der unabhängigen Variablen (“parents”, Eltern) bezeichnet.\nIn einem simplen BN mit A –&gt; B wäre A also der Parent und B das Kind (Child).\n\n\n\n\n\nAbb. 6: Eltern- und Kind-Knoten in einem einfachen Graphen\n\n\n\n\nIn einem etwas komplexeren Graphen können Knoten auch mehrere parents (grün) sowie children (grau) haben.\n\n\n\n\n\nAbb. 7: Graph mit mehreren Eltern- und Kind-Knoten\n\n\n\n\n\n\n\nDAGs können immer in drei fundamentale Strukturen zerlegt werden, die die Grundlage für die sogenannte D-Seperation bilden. D-Seperation ist ein zentrales Konzept in Bayes’schen Netzwerken für die Überprüfung der Abhängigkeit oder Unabhängigkeit von zwei Variablen.\n1) Serial: Die serielle Struktur\n\n\n\n\n\nAbb. 8: Serielle Struktur\n\n\n\n\nIn der seriellen Struktur besteht ein Kausalzusammenhang von A zu B und von B zu C. B fungiert also als Mediatorvariable des Einflusses von A auf C. Im Kontext der D-Separation sind A und C somit zunächst - indirekt - abhängig voneinander. Wenn man jedoch auf B konditioniert, blockiert B den Weg von A zu C und diese werden unabhängig voneinander. Mit anderen Worten: Wenn für B ein bestimmter Zustand festgelegt wird, für den der Einfluss auf C berechnet werden soll, wird der Zustand von A irrelevant für die Berechnung der Wahrscheinlichkeit von C.\n2) Divergent: Die divergente Struktur\n\n\n\n\n\nAbb. 9: Divergente Struktur\n\n\n\n\nIn der divergenten Struktur sind A und C Child-Knoten von B. B beeinflusst also sowohl A als auch C. In der D-Seperation sind A und C zunächst abhängig voneinander. Dies ändert sich jedoch, wenn man auf B konditioniert: B blockiert den Pfad von A zu C, wenn wir auf B knoditionieren, sodass A und C dann unabhängig werden. In der seriellen und der divergenten Struktur blockiert B also den Pfad von A zu C.\n3) Convergent: Die konvergente Struktur\n\n\n\n\n\nAbb. 10: Konvergente Struktur\n\n\n\n\nIn der konvergenten Struktur sind A und C die Parent-Knoten von B. B ist also abhängig von A und von C. Dabei sind A und C zunächst unabhängig voneinander. Die ändert sich jedoch, wenn man auf B konditioniert. Da sowohl A als auch C einen Einfluss auf B ausüben, besteht auch zwischen A und C eine Abhängigkeit sobald ein Wert für B konditioniert wird (da dieser Wert sowohl auf A als auch C basiert). Dies gilt auch für alle potentiellen Child-Knoten von B.\nAuf diese Weise können alle direkten und indirekten Kausalitäten von Variablen in einem BN identifiziert werden. Dazu eignen sich die path.exist() und die dsep()-Funktionen im bnlearn-Paket. Darauf kommen wir später noch einmal zurück.\n\nBeispiel für D-Separation:\nEin einfaches Beispiel für ein besseres Verständnis der D-Seperation liefern Geiger, Verma und Pearl (1990, S. 513, Übersetzung V.B.):\n[…] Wenn jede Variable als Knoten dargestellt wird und Kanten zwischen den Knoten die kausalen Abhängigkeiten der Variablen darstellen, ergibt sich eine grafische Abbildung der kausalen Hierarchie. Ein Beispiel: Die Aussagen “es regnet” (A), “der Gehweg ist nass” (B) und “John ist auf dem Gehweg ausgerutscht” (C) lassen sich durch eine Kette von drei Knoten - von A durch B zu C - abbilden. Es liegt Nahe, dass entweder Regen oder ein nasser Gehweg ursächlich für das Ausrutschen sein können, dennoch wird der nasse Gehweg als kausal ursächlich für das Ausrutschen dargestellt: Regen kann dazu führen, dass jemand auf dem Gehweg ausrutscht - allerdings nicht, wenn der Gehweg überdacht ist.\nErgebnis: Wenn die Kondition des Gehwegs (nass/trocken) bekannt ist, führt dies zu einer Unabhängigkeit der Variablen Regen und Ausrutschen.\n\n\n\n\n\nAbb. 11: Beispiel von Geiger, Verma & Pearl (1990, S. 513)"
  },
  {
    "objectID": "bbn.html#beispiel-das-asia-netzwerk-1988",
    "href": "bbn.html#beispiel-das-asia-netzwerk-1988",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "2 Beispiel: Das Asia-Netzwerk (1988)",
    "text": "2 Beispiel: Das Asia-Netzwerk (1988)\nEin sehr bekanntes Beispiel für Bayes’sche Netzwerke ist das Asia-Netzwerk, das auf einem syntethischen Datensatz von Lauritzen und Spiegelhalter (1988) basiert. Der Datensatz ist im bnlearn-Package integriert. Der Datensatz besteht aus 8 Variablen und 5000 Fällen. Die Variablen sind:\n\nD (dyspnoea), eine Zwei-Level Faktorvariable (yes/no)\nT (tuberculosis), eine Zwei-Level Faktorvariable (yes/no)\nL (lung cancer), eine Zwei-Level Faktorvariable (yes/no)\nB (bronchitis), eine Zwei-Level Faktorvariable (yes/no)\nA (visit to Asia), eine Zwei-Level Faktorvariable (yes/no)\nS (smoking), eine Zwei-Level Faktorvariable (yes/no)\nX (chest X-ray), eine Zwei-Level Faktorvariable (yes/no)\nE (tuberculosis versus lung cancer/bronchitis), eine Zwei-Level Faktorvariable (yes/no)\n\nAufgrund der Übersichtlichkeit (wenige Variablen mit wenigen Ausprägungen) wird dieses Beispiel oft als Einstieg in das Thema der Bayes’schen Netzwerke gewählt, obwohl es sich um ein synthetisches Beispiel handelt, das von empirischen Daten nicht bestätigt werden konnte. Die von Lauritzer und Spiegelhalter formulierte Kausalannahme zu diesem Beispiel lautet:\n“Shortness-of-breath (dyspnoea) may be due to tuberculosis, lung cancer or bronchitis, or none of them, or more than one of them. A recent visit to Asia increases the chances of tuberculosis, while smoking is known to be a risk factor for both lung cancer and bronchitis. The results of a single chest X-ray do not discriminate between lung cancer and tuberculosis, as neither does the presence or absence of dyspnoea.” (Lauritzer & Spiegehalter, 1988, S. 163)\n\n&gt; # Asia-Datensatz laden\n&gt; data(asia)\n&gt; \n&gt; # Daten ansehen\n&gt; head(asia, 5)\n\n   A   S   T  L   B   E   X   D\n1 no yes  no no yes  no  no yes\n2 no yes  no no  no  no  no  no\n3 no  no yes no  no yes yes yes\n4 no  no  no no yes  no  no yes\n5 no  no  no no  no  no  no yes\n\n\n\n2.1 Netzwerkstruktur implementieren und Netzwerk anzeigen\nMit der Funktion model2network() können wir die Netwerkstruktur manuell definieren. Dabei werden die einzelnen Kausalzusammenhänge zwischen den Variablen, die im Netzwerk abgebildet werden sollen, jeweils in eckigen Klammern dargestellt.\n\n&gt; # Netzwerkstruktur implementieren\n&gt; dag_asia &lt;- model2network(\"[A][S][T|A][L|S][B|S][D|B:E][E|T:L][X|E]\")\n&gt; \n&gt; # Netzwerkstruktur anzeigen\n&gt; graphviz.plot(dag_asia)\n\n\n\n\nAbb. 12: Das Asia-Netzwerk\n\n\n\n\nDie Schreibweise zur Implementierung der Netzwerkstruktur ist wie folgt: [abhängige Variable | unabhängige Variable] Wenn mehrere Pfeile von oder zu einer Variablen dargestellt werden sollen, können diese durch Doppelpunkte getrennt werden: [abhängige Variable | unabhängige Variable 1 : unabhängige Variable 2].\nDas bnlearn-Paket erlaubt viele weitere Möglichkeiten, die Netzwerkstruktur zu implementieren. Eine Übersicht gibt es hier: https://www.bnlearn.com/examples/dag/\n\n\n2.2 Parameter lernen\nAus der Netzwerkstruktur und den hinterlegten Daten können nun die CPTs errechnet werden. Dies kann manuell passieren. Das bnlearn-Paket hat aber auch eine entsprechende Funktion implementiert. Wir übergeben der Funktion also einfach den Datensatz mit unserem empirischen Daten und bnlearn berechnet die bedingten Wahrscheinlichkeiten dann anhand der empirischen Evidenz mithilfe der bnfit()-Funktion:\n\n&gt; bn_asia &lt;- bn.fit(dag_asia, data = asia, method = \"mle\")\n\nMit dem bn_asia-Objekt können nun die Wahrscheinlichkeiten für bestimmte Kombinationen an Evidenz abgefragt werden. Wenn wir zum Beispiel die Wahrscheinlichkeit dafür wissen wollen, dass ein X-Ray positiv ist und wir wissen bereits, dass die Person raucht, aber in letzter Zeit nicht in Asien war, können wir die Abfrage wie folgt formulieren:\n\n&gt; cpquery(bn_asia, event = (X == \"yes\"), \n+         evidence = ((A == \"no\") & (S == \"yes\")))\n\n[1] 0.1492659\n\n\nDas Event, für das die Wahrscheinlichkeit gesucht wird, ist X==\"yes\" (X-Ray ist positiv) unter der Bedingung, dass A==\"no\" (Person war nicht in Asien) und S==\"yes\" (Person raucht).\nIn Kapitel 4 schauen wir uns auch an, wie man vorgeht, wenn man die bedingten Wahrscheinlichkeiten manuell berechnen möchte. Das kann zum Beispiel dann hilfreich sein, wenn man Daten aus mehreren Datenquellen miteinander kombinieren möchte und nicht nur einen einzigen Datensatz mit empirischen Daten vorliegen hat."
  },
  {
    "objectID": "bbn.html#bayessche-netzwerke-erstellen",
    "href": "bbn.html#bayessche-netzwerke-erstellen",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "3 Bayes’sche Netzwerke erstellen",
    "text": "3 Bayes’sche Netzwerke erstellen\nPrinzipiell gibt es zwei Möglichkeiten, Bayes’sche Netzwerke zu erstellen und Kausalzusammenhänge damit zu analysieren. Die erste Variante ist, das Modell aufgrund theoretischer Annahmen zu erstellen und dann mit Daten zu füttern. Der Ausgangspunkt hier ist also eine Theorie, bzw. eine Annahme über die Variablen, die benötigt werden, um ein Phänomen zu beschreiben und wie diese Variablen zusammenhängen. In der zweiten Variante können Zusammenhänge zwischen Variablen aus empirischen Daten erlernt werden.\n\n3.1 Netzwerkstruktur manuell erstellen (expert systems)\nDieses Vorgehen ist dann geeignet, wenn man eine Annahme darüber hat, wie verschiedene Variablen zusammenhängen könnten und wenn man diese Annahmen anhand von Daten oder Expert:inneneinschätzungen prüfen möchte und die Relevanz der einzelnen Variablen für das Ergebnis berechnen möchte. Dazu werden sowohl die Netzwerkstruktur als auch die bedingten Wahrscheinlichkeiten, mit denen die Netzwerkstruktur unterlegt wird, manuell implementiert. Eine ausführliche Beschreibung für die Umsetzung in R gibt es in Kapitel 4.\n\nBayes’sche Netzwerke als Expert:innensysteme:\nEin großer Vorteil Bayes’scher Netzwerke ist, dass sie als sogenannte Expert:innensysteme fungieren können. Das heißt, dass die angenommene Struktur des Netzwerkes und damit der Kausalzusammenhänge auf Basis der Einschätzung von Expert:innen geschehen kann (z.B. durch Expert:inneninterviews, gemeinsame Workshops, oder bestehende Forschungs- und Datengrundlagen zu einem Thema). Diese Expert:innen können sowohl an der Erarbeitung der Kausalstruktur, also des Netzwerks, beteiligt werden, als auch Einschätzungen zu den bedingten Wahrscheinlichkeiten geben. Damit bieten Bayes’sche Netzwerke großes Potential für die Beteiligung von Stakeholdern in der Planungs- und Umsetzungsphase von Projekten.\nEine Besonderheit ist zudem, dass Daten aus verschiedenen Quellen miteinander kombiniert werden können. Da Bayes’sche Netzwerke CPTs als Input nutzen und die Wahrscheinlichkeiten dieser CPTs dem Modell manuell übergeben werden können (vgl. Kapitel 4), müssen die CPTs für verschiedene Variablen nicht alle aus demselben Datensatz stammen. Es können auch bedingte Wahrscheinlichkeitstabellen aus verschiedenen Datenquellen berechnet werden, wenn diese Datenquellen Zusammenhänge zwischen Variablen beinhalten, die für das vorliegende Kausalmodell relevant sind.\nDies ist zum Beispiel dann sinnvoll, wenn eine Maßnahme oder ein Projekt noch am Anfang der Planung steht, sodass noch keine eigenen Daten erhoben werden konnten. Auch eine Kombination aus Expert:inneneinschätzungen und Sekundärdaten ist möglich.\nNatürlich gilt, wie immer, wenn es um Datenanalysen geht: Die Aussagekraft des Modells ist besser, je besser die Datengrundlage ist.\nDaher ist es ratsam, im Falle von Expert:inneneinschätzungen und/oder Sekundäranalsen im weiteren Verlauf des Projektvorgehens Daten zu sammeln, die sich auf den eigenen, tatschlichen Use Case beziehen, um die Annahmen im Modell auch mit direkter empirischer Evidenz unterlegen und überprüfen zu können. Gerade zu Beginn eines Projektes ist die Arbeit mit Sekundärdaten und Expert:inneneinschätzungen jedoch ein sinnvoller erster Schritt, um zu schauen, welche der theoretischen Annahmen über die Zusammenhänge geplanter Handlungsschritte sinnvoll sind.\n\n\n3.2 Netzwerkstruktur aus Daten lernen (structure learning)\nDie zweite Möglichkeit ist es, die Netzwerkstruktur aus den Daten zu lernen. Diese Variante ist geeignet, wenn empirische Daten zu einem Sachverhalt vorliegen, wenn aber zum Beispiel noch keine genaue Vorstellung davon vorhanden ist, wie diese Daten zusammenhängen könnten. Mit anderen Worten: Anstatt mit einer Idee davon zu starten, wie unterschiedliche Variablen zusammenhängen könnten (z. B. wie in einer Theory of Change), werden die Zusammenhänge und damit die Kanten des Netzwerks aus den Daten erschlossen.\nDer Vorteil besteht darin, dass kein bzw. nur wenig Vorwissen zu einem bestimmten Themenbereich notwendig ist. Der Nachteil besteht darin, dass die Datengrundlage stark darüber entscheidet, wie gut das Modell ist. Wenn etwa relevante Variablen in einem Datensatz fehlen oder Zusammenhänge aufgrund eines Stichproben-Bias nicht abgebildet werden können, wird ein solches Modell keine sinnvollen Ergebnisse liefern können.\nFür die Inferenz der Netzwerkstruktur aus einem vorhandenen Datensatz gibt es verschiedene Algorithmen, die jeweils unterschiedliche Vor- und Nachteile mitbringen. Im bnlearn-Packet sind die folgenden Algorithmen implementiert:\n\nconstraint-based (PC Stable, Grow-Shrink, IAMB, Fast-IAMB, Inter-IAMB, IAMB-FDR, MMPC, Semi-Interleaved HITON-PC, HPC),\nscore-based (hill climbing und tabu search)\nund hybrid (MMHC, H2PC, RSMAX2).\n\nEine ausführliche Erklärung der verschiedenen Algorithmen findet sich in der Dokumentation des bnlearn-Pakets und unter https://www.bnlearn.com/.\nEs ist natürlich auch möglich, zunächst Annahmen über die Kausalzusammenhänge der Variablen auf Basis bestehender Forschung zu formulieren und diese Annahmen dann mit dem erlernten Netzwerk aus den empirischen Daten zu vergleichen. Dies hilft dabei, die theoretischen Annahmen zu überprüfen und zu verbessern."
  },
  {
    "objectID": "bbn.html#ein-bayessches-netzwerk-am-beispiel-des-e-valuate-projekts-erstellen",
    "href": "bbn.html#ein-bayessches-netzwerk-am-beispiel-des-e-valuate-projekts-erstellen",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "4 Ein Bayes’sches Netzwerk am Beispiel des E-Valuate-Projekts erstellen",
    "text": "4 Ein Bayes’sches Netzwerk am Beispiel des E-Valuate-Projekts erstellen\nDas Projekt E-Valuate - Auf dem Weg zum lernenden Staat ist ein vom Bundesministerium für Digitales und Verkehr (BMDV) bis Ende 2025 gefördertes Forschungsprojekt. Anhand der Digitalstrategie der Bundesregierung werden Projekte aus der Digitalstrategie in Form von Reallaboren begleitet und Methoden für wirkungsorientiertes Arbeiten erprobt.\nDie zentrale Frage des hier beispielhaft berechneten BNs ist also, welche Faktoren dazu führen, dass Wirkungsorientierung in der Umsetzung eines Projektes implemeniert wird.\nDazu haben wir eine Theory of Change (ToC) erstellt. Die ToC ist ein Wirkungsmodell, dass es erlaubt, die angenommenen Kausalzusammenhänge zwischen einzelnen Handlungsschritten und ihren Ergebnissen als Netzwerkgraph darzustellen. Die Handlungsschritte und Ergebnisse werden dabei jeweils als individuelle Events (Knoten) in des Modell aufgenommen. Die Kausalzusammenhängen werden als Pfeile (Kanten) dargestellt. Eine ToC folgt damit denselben Grundprizipien wie die Darstellung Bayes’scher Netzwerke. Wenn die ToC den Anforderungen folgt, denen Bayes’sche Netzwerke unterliegen (vgl. Kapitel 1), ist sie die ToC eine gute Basis für die Struktur eines BN.\nDie dargestellten Annahmen über die Kausalzusammenhänge der Variablen lauten beispielhaft folgendermaßen: Die Projektart hat einen Einfluss darauf, wie viele Ministerien und externe Organisationen an der Umsetzung des Projekts beteiligt sind (z.B. weil bestimmte Kompetenzen benötigt werden). Wenn mehrere Ministerien und dienstleistende Organisationen an der Projektumsetzung beteiligt sind, hat das einen Einfluss darauf, ob Mitarbeitende praktische Erfahrung mit und theoretisches Wissen über Wirkungsorientierung haben (z. B. weil es bei mehreren Beteiligten wahrscheinlicher ist, dass einige Mitarbeitende schon mit entsprechenden Methoden und Lernmaterialien gearbeitet haben und dies an das restliche Team weitergeben können). Außerdem kann die Nutzung von Wissensressourcen einen direkten Einfluss auf das theoretische Wissen ausüben. Wissen über und Erfahrung mit Wirkungsorientierung bei den Mitarbeitenden beeinflussen schließlich, ob Wirkungsorientierung in Projekten implementiert wird. Die dazugehörige ToC sieht so aus:\n\n\n\nAbb. 13: ToC: Implementierung von Wirkungsorientierung in Projekten (Anmerkung: Die Pfeile stellen angenommene Kausalzusammenhänge zwischen den Variablen dar.)\n\n\nAchtung: Bei der Erstellung einer ToC neigt man manchmal dazu, jeden kleinen Zwischenschritt und seine Auswirkungen auf die anderen Events abbilden zu wollen. Wenn das Ziel ist, die ToC als Basis für ein Bayes’sches Netzwerk zu nutzen, müssen jedoch die Einschränkungen Bayes’scher Netzwerke betrachtet werden. Insbesondere ist wichtig, dass die ToC keine Zirkelschlüsse (Loops) enthält. Mit anderen Worten: An keiner Stelle im Netzwerk dürfen sich Variablen selbst erklären.\nZudem ist es ratsam, darauf zu achten, dass die ToC nicht zu komplex wird. Dies hat vorallem forschungspraktische Gründe. Bayes’sche Netzwerke können prinzipiell gut mit vergleichsweisen großen Datenmengen umgehen, da sie sich auf eine lokale Berechnung der Wahrscheinlichkeiten beschränken (für eine ausfürhliche Erklärung siehe Scutari & Denis, 2022), allerdings muss berücksichtigt werden, dass die CPTs schnell komplex werden, wenn ein Knoten viele Abhängigkeiten (parents) hat.\n\n4.1 Das Netzwerk implementieren\nZunächst müssen wir die Netzwerkstruktur implementieren. Dazu orientieren wir uns an der ToC. Das beispielhafte Modell enthält sieben Variablen:\n\nWirkung: Die Variable misst anhand eines eigens entwickelten Wirkungsindex (Skala: 0-100), ob Wirkungsorientierung in einem Projekt integriert ist. Diese metrische Variable wird zu einer dichotomen Variablen mit den Ausprägungen ja (Wirkungsorientierung ist implementiert) und nein (Wirkungsorientierung ist nicht implementiert) umcodiert. Wirkung = ja wird angenommen, wenn der Wirkungsindex über 50 liegt.\nErfahrung: Die Variable misst, ob die Befragten Mitarbeitenden praktische Erfahrung mit Wirkungsorientierung haben. Es handelt sich um eine dichotome Variable (ja, nein).\nWissen: Die Variable misst, ob die Befragten angeben, dass sie sich bereits mit dem Thema Wirkungsorientierung beschäftigt haben. Es handelt sich um eine dichotome Variable (ja, nein).\nRessourcen: Die Variable misst, ob Wissensressourcen (z. B. Leitfäden, (Online-)Kurse, etc.) über Wirkungsorientierung von den Mitarbeitenden genutzt werden. Es handelt sich um eine dichotome Variable (ja, nein).\nMinisterien: Die Variable misst, ob mehrere Ministerien an der Umsetzung des Projekts berteiligt sind. Es handelt sich um eine dichotome Variable (ja, nein).\nOrganisationen: Die Variable misst, ob externe Organisationen an der Umsetzung beteiligt sind. Es handelt sich um eine kategoriale Variable mit drei Ausprägunge (ja, nein, unklar).\nProjektart: Die Variable gibt an, um welche Art von Projekt es sich handelt. Es handelt sich um eine Faktorvariable mit sechs Ausprägungen (Digitalisierung, Strategie, Förderung, Gesetzgebung, Organisation, Sonstiges).\n\n\nNetzwerkstruktur in R implementieren:\nDie Netzwerkstruktur implementieren wir manuell auf Basis der ToC.\n\n&gt; # Wir definieren die Knoten des Graphen\n&gt; nodes_evaluate = empty.graph(nodes = c(\"wirkung\", \"erfahrung\", \"wissen\", \"ressourcen\", \"ministerien\", \"organisationen\", \"projektart\"))\n&gt; \n&gt; # Dann definieren wir die Netzwerkstruktur, also die Kanten zwischen den Knoten\n&gt; # Achtung: Die Namen der Knoten müssen genau so sein, wie im ersten Schritt definiert\n&gt; dag_evaluate &lt;- model2network(\"[projektart][ressourcen][wirkung|wissen:erfahrung][wissen|ressourcen:organisationen][erfahrung|ministerien:organisationen][ministerien|projektart][organisationen|projektart]\")\n&gt; \n&gt; # Graphen ansehen und mit der ToC vergleichen\n&gt; graphviz.plot(dag_evaluate)\n\n\n\n\nAbb. 14: Das E-Valuate-Netzwerk\n\n\n\n\nEs fällt auf, dass bnlearn die Variablen genau so anordnet, wie in unserer Theory of Change. Die empirischen Datengrundlage ist eine quantitative Onlineumfrage unter Mitarbeitenden der Verwaltung im Kontext der Digitalstrategie, die im April und Mai 2024 durchgeführt wurde.\n\n\n4.2 Modell fit: Das Modell mit Daten füttern\nWenn für alle Variablen des Modells Daten in einem Datensatz vorliegen, können diese dazu genutzt werden, die Wahrscheinlichkeitsverteilungen zu berechnen, mit denen die Kausalbeziehungen im Netzwerk hinterlegt werden.\nZunächst verschaffen wir uns einen Überblick über die Variablen im Datensatz und führen ein paar Bereinigungs- und Vorbereitungsschritte durch.\n\n&gt; # Variablennamen anziegen\n&gt; names(df_bn)\n\n[1] \"projektart\"     \"organisationen\" \"ministerien\"    \"ressourcen\"    \n[5] \"erfahrung\"      \"wissen\"         \"wirkung\"       \n\n&gt; # Übersicht über das Objekt und die Variablenarten mit str()\n&gt; # Alle Variablen müssen factor sein\n&gt; str(df_bn)\n\n'data.frame':   86 obs. of  7 variables:\n $ projektart    : chr  \"Förderung\" \"Gesetzgebung\" \"Gesetzgebung\" \"Strategieentwicklung\" ...\n $ organisationen: chr  \"nein\" \"ja\" \"ja\" \"ja\" ...\n $ ministerien   : chr  \"nein\" \"nein\" \"ja\" \"nein\" ...\n $ ressourcen    : chr  NA \"nein\" NA NA ...\n $ erfahrung     : chr  NA \"ja\" NA NA ...\n $ wissen        : chr  NA \"nein\" NA NA ...\n $ wirkung       : chr  \"ja\" \"ja\" \"nein\" \"nein\" ...\n\n&gt; # NAs behandeln wir in diesem Fall wie \"nein\"-Antworten\n&gt; df_bn[is.na(df_bn)] &lt;- \"nein\"\n&gt; \n&gt; # chr-Variablen zu factor-Variablen\n&gt; # Linke Seite der Zuweisung identifiziert alle Variablen im df, die chr sind\n&gt; # sapply links ist notwendig, damit das Objekt ein df und keine Liste ist\n&gt; # Rechte Seite führt as.factor für jede chr-Variable aus\n&gt; df_bn[sapply(df_bn, is.character)] &lt;- lapply(df_bn[sapply(df_bn, is.character)], \n+                                        as.factor)\n\nFür die Berechnung der konditionellen Wahrscheinlichkeiten aus den vorliegenden empirischen Daten nutzen wir dann die bnfit-Funktion aus bnlearn:\n\n&gt; # bn.fit-Fuktion\n&gt; bn_mle &lt;- bn.fit(dag_evaluate, data = df_bn, method = \"mle\")\n\n\n\n4.3 CPTs manuell berechnen\nEs ist auch möglich, die CPTs selbst zu berechnen und einzeln an das Modell zu übergeben. Das ist dann hilfreich, wenn diverse Datengrundlagen miteinander kombiniert werden sollen. Beispielhaft machen wir das hier für eine Variable.\nAchtung: Dies ist eine Alternative zur Berechnung über die bn.fit()-Funktion. Diese Schritte sind nicht notwendig, wenn alle Variablen in einem Datensatz vorliegen.\nDie Formel für bedingte Wahrscheinlichkeiten lautet:\nP(B | A) = P(A and B) / P(A) .\nIn R berechnen wir bedingte Wahrscheinlichkeiten ganz einfach mit der prop.table()-Funktion aus Base R.\n\n# Berechnung der CPTs mit der prop.table()-Funktion in Base-R für Eltern-Knoten\ncpt_projektart &lt;- prop.table(table(df_bn[, \"projektart\"]))\n\n# Für Zusammenhänge mehrerer Knoten\n# Wir setzen margin=1, damit die Wahrscheinlichkeiten abhängig von der ersten Variable (Ressourcen) berechnet werden\ncpt_wiss_ress &lt;- prop.table(table(df_bn[, c(\"ressourcen\", \"wissen\")]), margin = 1)\n\n# Für mehr als zwei Knoten\ncpt_wiss_ress &lt;- prop.table(table(df_bn[, c(\"wissen\", \"ressourcen\")]), margin = 1)\n\n\nExpert:inneneinschätzungen:\nWenn die Wahrscheinlichkeiten auf Expert:inneneinschätzungen beruhen, kann man die CPTs als Matrix selbst aufsetzen (Achtung: die Wahrscheinlichkeit hier sind nur ein Beispiel und entsprechen nicht den tatsächlichen Werten):\n\n# Für die Parent-Variablen sind die Tabellen klein\ncpt_ressourcen &lt;- matrix(c(0.4, 0.6), ncol = 2, dimnames = list(NULL, c(\"Ja\", \"Nein\")))\n\n# Für zwei Variablen und mehrere Kategoren wird es etwas komplexer\ncpt_ministerien &lt;- array(c(0.4, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.2, 0.2, 0.1, 0.1, 0.1, 0.1, 0.1), dim = c(7,2), dimnames = list(\"projektart\" = c(\"Digitalisierung\", \"Förderung\", \"Gesetzgebung\", \"IT-Entwicklung\", \"Organisationsmaßnahme\", \"Sonstiges\", \"Strategientwicklung\"), \"ministerien\" = c(\"ja\", \"nein\")))\n\n# Für drei Variablen muss die dim-Option entsprechend angepasst werden\ncpt_erfahrung &lt;- array(c(0.5, 0.5, 0.4, 0.6, 0.3, 0.7, 0.2, 0.8), dim = c(2, 2, 2), dimnames = list(\"erfahrung\" = c(\"ja\", \"nein\"), \"ministerien\" =  c(\"Ja\", \"Nein\"), \"organisationen\" = c(\"ja\", \"nein\")))\n\n\ncustom.fit()-Funktion:\nWenn die CPTs manuell berechnet oder auf Basis von Expert:inneneinschätzungen angelegt wurden, nutzen wir zum übertragen in das Modell die custom.fit- statt der bn.fit-Funktion aus dem bnlearn-Paket:\n\n# Wir übergeben alle lokalen Verteilungen (CPTs) an eine Liste, die wir in custom.fit() einlesen können\n\n# Die Tabellen werden den entsprechenden Knotennamen zugeordneten, damit bnlearn die Wahrscheinlichkeiten zuordnen kann\ncpts_evaluate &lt;- list(ressourcen = cpt_ressourcen, ministerien = cpt_ministeiren, erfahrung = cpt_erfahrung) #usw.\n\n# BN berechnen\nbn_custom &lt;- custom.fit(dag_evaluate, cpts_evaluate)\n\n\n\n4.4 Modellübersicht\nIm fertigen bn.fit-Objekt (entweder aus der bn.fit oder der custom.fit-Funktion) sind die Kausalannahmendes DAGs nun mit Daten hinterlegt, sodass wir verschiedene Arten von Abfragen an das Modell stellen können.\nDie Funktion nparams() gibt die Anzahl der Parameter im Modell aus:\n\n&gt; nparams(bn_mle)\n\n[1] 44\n\n\nDie Funktion arcs() zeigt die Pfeile des Netzwerks in Form einer Kantenliste an:\n\n&gt; arcs(bn_mle)\n\n     from             to              \n[1,] \"erfahrung\"      \"wirkung\"       \n[2,] \"ministerien\"    \"erfahrung\"     \n[3,] \"organisationen\" \"erfahrung\"     \n[4,] \"organisationen\" \"wissen\"        \n[5,] \"projektart\"     \"ministerien\"   \n[6,] \"projektart\"     \"organisationen\"\n[7,] \"ressourcen\"     \"wissen\"        \n[8,] \"wissen\"         \"wirkung\"       \n\n\nEine Übersicht über weitere Befehle gibt es hier: https://www.bnlearn.com/documentation/bnlearn-manual.pdf\n\nExact Inference:\nFür die genaue Berechnung der Wahrscheinlichkeiten für das Eintreten bestimmter Events unter der Berücksichtigung anderer Variablen im Netzwerk ist das gRain-Paket notwendig. Das Bayes’sche Netzwerk wird dazu zunächst in einen junction tree, also eine Baumstruktur, überführt.\n\n&gt; library(gRain)\n&gt; \n&gt; # BN zu junction tree \n&gt; junction &lt;- compile(as.grain(bn_mle))\n\nAnschließend lassen sich die Wahrscheinlichkeiten bestimmter Knoten abfragen.\n\n&gt; q &lt;- gRain::querygrain(junction, nodes = \"wirkung\")\n&gt; q$wirkung\n\nwirkung\n       ja      nein \n0.6311622 0.3688378 \n\n\nEs lassen sich auch Evidenzen für bestimmte Variablen festlegen. So lässt sich zum Beispiel die Wahrscheinlichkeit für wirkung = ja abfragen, wenn es sich um ein Digitalisierungsprojekt handelt:\n\n&gt; # Dazu setzen wir zunächst die Werte fest, die abgefragt werden sollen\n&gt; junction_digi &lt;- gRain::setEvidence(junction, nodes = \"projektart\", states = \"Digitalisierung\" )\n&gt; \n&gt; # Danach können wir die Wahrscheinlichkeit wie oben abfragen\n&gt; q &lt;- gRain::querygrain(junction_digi, nodes = \"wirkung\")\n&gt; q$wirkung\n\nwirkung\n       ja      nein \n0.6334746 0.3665254 \n\n\n\nApproximate Inference:\nAlternativ können Monte Carlo-Simulationen genutzt werden, um Schätzungen über die Wahrscheinlichekiten für das Eintreten bestimmter Ereignisse zu machen. Dazu werden zunächst auf Basis der Daten Beobachtungen simuliert, aus diese wird dann die Wahrscheinlichkeit für ein bestimmtes Ereignis geschätzt. Bei Monte Carlo-Simulationen werden wiederholt Zufallsstichproben einer Verteilung generiert.\nDies ist im cpquery-Befehl des bnlearn-Pakets implementiert. Approximate Inference ist vor allem dann sinnvoll, wenn die Fallzahl der empirischen Daten gering ist oder wenn es sich um Expert:inneneinschätzungen handelt. Hier ein paar Beispiele für unterschiedliche Abfragen:\n\n&gt; # in bnlearn enthalten\n&gt; cpquery(bn_mle, event = (wirkung == \"ja\"), \n+         evidence = ((wissen == \"ja\") & (erfahrung == \"ja\")))\n\n[1] 0.6077105\n\n&gt; cpquery(bn_mle, event = (wirkung == \"ja\"), \n+         evidence = ((wissen == \"nein\") & (erfahrung == \"nein\")))\n\n[1] 0.04844541\n\n&gt; cpquery(bn_mle, event = (wirkung == \"ja\"), \n+         evidence = ((wissen == \"nein\") & (erfahrung == \"ja\")))\n\n[1] 0.8316417\n\n&gt; cpquery(bn_mle, event = (wirkung == \"ja\"), \n+         evidence = ((projektart == \"Digitalisierung\") & (erfahrung == \"nein\")))\n\n[1] 0.0462963\n\n&gt; cpquery(bn_mle, event = (erfahrung == \"ja\"), \n+         evidence = ((ressourcen == \"nein\")))\n\n[1] 0.7766942\n\n&gt; cpquery(bn_mle, event = (wissen == \"ja\"), \n+         evidence = ((ressourcen == \"nein\")))\n\n[1] 0.2437082\n\n&gt; cpquery(bn_mle, event = (wissen == \"ja\"), \n+         evidence = ((ressourcen == \"nein\")))\n\n[1] 0.2497928\n\n\nWir müssen berücksichtigen, dass es sich um Schätzungen handelt. Bei wiederholter Abfrage derselben Variablen können also leicht unterschiedliche Werte herauskommen. Zudem werden die Wahrscheinlichkeiten leicht von der exakten Abfrage mit dem gRain-Paket (siehe oben) abweichen.\nDie Genauigkeit der Schätzung kann verbessert werden, indem die Fallzahl (n) erhöht wird. Allerdings führt dies zu sehr langen Rechenzeiten. Eine bessere Option ist das likelihood weighting, das im cpquery-Paket über die Option method=\"lw\" implementiert ist: “Likelihood weighting generates random observations in such a way that all of them match the evidence, and re-weights them appropriately when computing the conditional probability for the query.” (Scutari & Denis, 2022, S. 27)\n\n&gt; cpquery(bn_mle, event = (wirkung == \"ja\"), evidence = list(wissen = \"nein\"), method = \"lw\")\n\n[1] 0.6574252\n\n\nAchtung: Wenn method=lw gesetzt wird, gibt es die Besonderheit, dass evidence als Liste übergeben werden muss. Wir müssen hier also den list()-Befehl ergänzen wie oben geschehen.\nDie simulierten Beobachtungen können mithilfe des cpdist-Befehls auch in einen Datensatz überführt werden. Dieser Ansatz ist extrem hilfreich, um etwa simulierte Daten für Expert:inneneinschätzungen zu generieren. Auf der Basis der so generierten Daten können dann weitere Analysen durchgeführt werden, um Annahmen über die Daten zu prüfen.\n\n&gt; # Datensatz simulieren\n&gt; simulated_df &lt;- cpdist(bn_mle, nodes=c(\"wirkung\", \"wissen\", \"ressourcen\"), evidence= (erfahrung == \"ja\"))\n&gt; \n&gt; # Erste 5 Fälle des df ansehen\n&gt; head(simulated_df, 5)\n\n  wirkung wissen ressourcen\n1      ja     ja       nein\n2      ja   nein       nein\n3      ja   nein       nein\n4      ja     ja       nein\n5      ja   nein       nein"
  },
  {
    "objectID": "bbn.html#bns-visualisieren",
    "href": "bbn.html#bns-visualisieren",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "5 BNs visualisieren",
    "text": "5 BNs visualisieren\nFür eine prägnante Darstellung lassen sich die Ergebnisse in die Netzwerkabbildung integrieren. Dazu bietet das bnlearn-Paket viele praktische Lösungen und Anspassungsmöglichkeiten, die die Umsetzung einfach machen.\nDie einfachste Möglicheit stellt der Befehl graphviz.chart() dar:\n\n&gt; # Für den Default-Plot übergeben wir nur das bn.fit-Objekt an die graphviz-Funktion\n&gt; graphviz.chart(bn_mle)\n\n\n\n\nAbb. 15: Fertiges BN mit Datenvisualisierung als Balkendiagramm\n\n\n\n\nDie Funktion liefert ein Netzwerk, in dem die Knoten als einfache Balkendiagramme dargestellt sind. Um die Daten in den Diagrammen übersichtlicher darzustellen, gibt es verschiedene optionale Argumente in graphviz.chart(). Mit type = \"barprop\" können beispielsweise die Werte angezeigt werden.\n\n&gt; graphviz.chart(bn_mle, type = \"barprob\")\n\n\n\n\nAbb. 16: Fertiges BN mit Datenvisualisierung als Balkendiagramm mit angezeigten Werten\n\n\n\n\nAuch farbliche Anpassungen sind möglich. Das Argument bar.col=\"\" bestimmt die Farbe der Balken und mit dem Argument strip.bg=\"\" kann die Kopfzeile der Diagramme farblich angepasst werden. Das Argument grid=TRUE kann genutzt werden, um vertikale Hilfslinien hinzuzufügen, die das Ablesen der Diagramme erleichtern. Mit der Default-Einstellung grid=TRUE werden diese Linien bei 0, 25, 50, und 75% eingefügt. Durch Angabe eines Vektors mit Dezimalzahlen (z.B. grid=c(0.2, 0.4, 0.6, 0.8)) ist es aber auch möglich, die Linien an individuellen Werten zu platzieren.\n\n&gt; graphviz.chart(bn_mle, type = \"barprob\", grid = TRUE, \n+                bar.col = \"violet\", strip.bg = \"lightskyblue\")\n\n\n\n\nAbb. 17: Fertiges BN mit Datenvisualisierung als Balkendiagramm mit angezeigten Werten und Farben"
  },
  {
    "objectID": "bbn.html#weiterführende-quellen",
    "href": "bbn.html#weiterführende-quellen",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "Weiterführende Quellen",
    "text": "Weiterführende Quellen\n\nTheorie Bayes’scher Netzwerke:\nGeiger, D., Verma, T., & Pearl, J. (1990). Identifying independence in Bayesian networks. Networks, 20(5), 507-534. http://ftp.cs.ucla.edu/pub/stat_ser/r116.pdf\nYang, X.-S., (2019). Introduction to Algorithms for Data Mining and Machine Learning. Academic Press.\nbnlearn-Paket:\nBeispiele für die Nutzung von bnlearn: https://www.bnlearn.com/examples/dag/\nDokumentation des bnlearn-Pakets: https://www.bnlearn.com/documentation/bnlearn-manual.pdf"
  },
  {
    "objectID": "bbn.html#referenzen",
    "href": "bbn.html#referenzen",
    "title": "Bayes’sche Netze: Machine Learning für Kausalanalysen bei Wirkungsorientierung",
    "section": "Referenzen",
    "text": "Referenzen\nGeiger, D., Verma, T., & Pearl, J. (1990). Identifying independence in Bayesian networks. Networks, 20(5), 507-534. http://ftp.cs.ucla.edu/pub/stat_ser/r116.pdf\nLauritzen S., Spiegelhalter D. (1988). Local Computation with Probabilities on Graphical Structures and their Application to Expert Systems (with discussion). Journal of the Royal Statistical Society: Series B, 50(2): 157–224.https://www.eecis.udel.edu/~shatkay/Course/papers/Lauritzen1988.pdf\nScutari, M., & Denis, J.-B., (2022). Bayesian Networks: With Examples in R. CRC Press.\nYang, X.-S., (2019). Introduction to Algorithms for Data Mining and Machine Learning. Academic Press."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Hier folgen Projektupdates in Form von Blogbeiträgen. Stay tuned."
  },
  {
    "objectID": "blog.html#projektupdates",
    "href": "blog.html#projektupdates",
    "title": "Blog",
    "section": "",
    "text": "Hier folgen Projektupdates in Form von Blogbeiträgen. Stay tuned."
  },
  {
    "objectID": "wirkungsserie.html",
    "href": "wirkungsserie.html",
    "title": "Wirkungsorientierung: Von der Zieldefinition zur Wirkungsanalyse",
    "section": "",
    "text": "Hier wird die Linked-In-Serie zu Wirkungsorientierung eingebaut."
  },
  {
    "objectID": "index.html#herzlich-willkommen-zu-den-projektupdates-des-projekts-e-valuate---auf-dem-weg-zum-lernenden-staat",
    "href": "index.html#herzlich-willkommen-zu-den-projektupdates-des-projekts-e-valuate---auf-dem-weg-zum-lernenden-staat",
    "title": "Willkommen",
    "section": "",
    "text": "Auf den folgenden Seiten findet ihr:\n\nTutorials zu Datenanalysen und Wirkungsorientierung\nCode- und Ergebnisdokumentationen zu den Datenanalysen aus dem E-Valuate-Projekt\nProjektupdates in Form von Blogbeiträgen.\n\nAusführliche Projektinformationen gibt es auf der offiziellen Projektwebsite: E-Valuate - Auf dem Weg zum lernenden Staat\nWir freuen uns über Feedback und Themenvorschläge. Schreibt uns dazu gern eine Mail an vivien.benert@agoradigital.de.\n\n\n\nVom politischen Ziel zur gesellschaftlichen Veränderung, Quelle: Agora Digitale Transformation"
  },
  {
    "objectID": "index.html#updates-des-projekts-e-valuate---auf-dem-weg-zum-lernenden-staat",
    "href": "index.html#updates-des-projekts-e-valuate---auf-dem-weg-zum-lernenden-staat",
    "title": "Willkommen",
    "section": "",
    "text": "Auf den folgenden Seiten findet ihr:\n\nTutorials zu Datenanalysen und Wirkungsorientierung\nCode- und Ergebnisdokumentationen zu den Datenanalysen aus dem E-Valuate-Projekt\nProjektupdates in Form von Blogbeiträgen.\n\nAusführliche Projektinformationen gibt es auf der offiziellen Projektwebsite: E-Valuate - Auf dem Weg zum lernenden Staat\nWir freuen uns über Feedback und Themenvorschläge. Schreibt uns dazu gern eine Mail an vivien.benert@agoradigital.de.\n\n\n\nVom politischen Ziel zur gesellschaftlichen Veränderung, Quelle: Agora Digitale Transformation"
  }
]